import { render, fireEvent } from '@testing-library/svelte';
import { vi, describe, it, expect, beforeEach } from 'vitest';
import { get } from 'svelte/store';
import DrawingCanvas from './DrawingCanvas.svelte';
import { drawingStore } from '../lib/stores/drawing';
import { chainStore, setChains } from '../lib/stores/chains';
import { partStore } from '../lib/stores/parts';
import { pathStore } from '../lib/stores/paths';
import { operationsStore } from '../lib/stores/operations';
import { overlayStore } from '../lib/stores/overlay';
import { rapidStore } from '../lib/stores/rapids';
import { tessellationStore } from '../lib/stores/tessellation';
import type { Shape, Drawing } from '../types';
import type { ShapeChain } from '../lib/algorithms/chain-detection';

// Mock the geometry/nurbs module
vi.mock('../lib/geometry/nurbs', () => ({
  sampleNURBS: vi.fn(() => []),
  evaluateNURBS: vi.fn(() => ({ x: 0, y: 0 }))
}));

describe('DrawingCanvas - Program Page Chain-Only Selection', () => {
  let mockDrawing: Drawing;
  let mockChains: ShapeChain[];
  let mockShapes: Shape[];

  beforeEach(() => {
    // Create test shapes that form two chains
    mockShapes = [
      {
        id: 'shape1',
        type: 'line',
        layer: '0',
        geometry: {
          start: { x: 0, y: 0 },
          end: { x: 10, y: 0 }
        }
      },
      {
        id: 'shape2', 
        type: 'line',
        layer: '0',
        geometry: {
          start: { x: 10, y: 0 },
          end: { x: 10, y: 10 }
        }
      },
      {
        id: 'shape3',
        type: 'line',
        layer: '0', 
        geometry: {
          start: { x: 20, y: 20 },
          end: { x: 30, y: 20 }
        }
      },
      {
        id: 'shape4',
        type: 'line',
        layer: '0',
        geometry: {
          start: { x: 30, y: 20 },
          end: { x: 30, y: 30 }
        }
      }
    ];

    mockDrawing = {
      id: 'test-drawing',
      fileName: 'test.dxf',
      units: 'mm',
      bounds: { minX: 0, minY: 0, maxX: 30, maxY: 30 },
      shapes: mockShapes
    };

    // Create chains - shape1+shape2 form chain1, shape3+shape4 form chain2  
    mockChains = [
      {
        id: 'chain1',
        shapes: [mockShapes[0], mockShapes[1]].map(s => ({ ...s })),
        bounds: { minX: 0, minY: 0, maxX: 10, maxY: 10 }
      },
      {
        id: 'chain2', 
        shapes: [mockShapes[2], mockShapes[3]].map(s => ({ ...s })),
        bounds: { minX: 20, minY: 20, maxX: 30, maxY: 30 }
      }
    ];

    // Load test data into stores
    drawingStore.setDrawing(mockDrawing);
    setChains(mockChains);
  });

  it('should only allow selecting entire chains when treatChainsAsEntities=true', async () => {
    const { container } = render(DrawingCanvas, {
      props: {
        treatChainsAsEntities: true,
        currentStage: 'program' as const,
        onChainClick: vi.fn()
      }
    });

    const canvas = container.querySelector('canvas') as HTMLCanvasElement;
    expect(canvas).toBeTruthy();

    // Click on shape1 (part of chain1)
    await fireEvent.mouseDown(canvas, {
      button: 0,
      offsetX: 50, // Should hit shape1 when transformed to world coordinates
      offsetY: 400  // Adjusted for canvas coordinate system
    });

    // Should select entire chain1 (both shape1 and shape2), not just shape1
    const selectedShapes = get(drawingStore).selectedShapes;
    expect(selectedShapes.has('shape1')).toBe(true);
    expect(selectedShapes.has('shape2')).toBe(true);
    expect(selectedShapes.has('shape3')).toBe(false);
    expect(selectedShapes.has('shape4')).toBe(false);
  });

  it('should not allow selecting individual shapes when treatChainsAsEntities=true', async () => {
    const onChainClick = vi.fn();
    const { container } = render(DrawingCanvas, {
      props: {
        treatChainsAsEntities: true,
        currentStage: 'program' as const,
        onChainClick
      }
    });

    const canvas = container.querySelector('canvas') as HTMLCanvasElement;

    // Click on shape1 
    await fireEvent.mouseDown(canvas, {
      button: 0,
      offsetX: 50,
      offsetY: 400
    });

    // Should call onChainClick with chain1 ID, not individual shape selection
    expect(onChainClick).toHaveBeenCalledWith('chain1');

    // Verify that the entire chain is selected, not individual shape
    const selectedShapes = get(drawingStore).selectedShapes;
    expect(selectedShapes.size).toBe(2); // Both shapes in the chain
    expect(selectedShapes.has('shape1')).toBe(true);
    expect(selectedShapes.has('shape2')).toBe(true);
  });

  it('should allow individual shape selection when treatChainsAsEntities=false', async () => {
    const { container } = render(DrawingCanvas, {
      props: {
        treatChainsAsEntities: false,
        currentStage: 'program' as const,
        onChainClick: null
      }
    });

    const canvas = container.querySelector('canvas') as HTMLCanvasElement;

    // Click on shape1
    await fireEvent.mouseDown(canvas, {
      button: 0,
      offsetX: 50,
      offsetY: 400
    });

    // Should select only shape1, not the entire chain
    const selectedShapes = get(drawingStore).selectedShapes;
    expect(selectedShapes.size).toBe(1);
    expect(selectedShapes.has('shape1')).toBe(true);
    expect(selectedShapes.has('shape2')).toBe(false);
  });

  it('should highlight entire chains on hover when treatChainsAsEntities=true', async () => {
    const { container } = render(DrawingCanvas, {
      props: {
        treatChainsAsEntities: true,
        currentStage: 'program' as const,
        onChainClick: vi.fn()
      }
    });

    const canvas = container.querySelector('canvas') as HTMLCanvasElement;

    // Hover over shape1 (part of chain1)
    await fireEvent.mouseMove(canvas, {
      offsetX: 50,
      offsetY: 400
    });

    // Wait for hover timeout
    await new Promise(resolve => setTimeout(resolve, 20));

    // Should set hovered shape to shape1, but rendering logic should highlight entire chain
    const hoveredShape = get(drawingStore).hoveredShape;
    expect(hoveredShape).toBe('shape1');
  });

  it('should deselect chain when clicking on already selected chain', async () => {
    const onChainClick = vi.fn();
    const { container } = render(DrawingCanvas, {
      props: {
        treatChainsAsEntities: true,
        currentStage: 'program' as const,
        onChainClick
      }
    });

    const canvas = container.querySelector('canvas') as HTMLCanvasElement;

    // First click to select chain1
    await fireEvent.mouseDown(canvas, {
      button: 0,
      offsetX: 50,
      offsetY: 400
    });

    expect(onChainClick).toHaveBeenCalledWith('chain1');

    // Clear the mock for the second call
    onChainClick.mockClear();

    // Second click on the same chain should deselect
    await fireEvent.mouseDown(canvas, {
      button: 0,
      offsetX: 60, // Still within chain1 area
      offsetY: 400
    });

    expect(onChainClick).toHaveBeenCalledWith('chain1');

    // Verify selection is cleared
    const selectedShapes = get(drawingStore).selectedShapes;
    expect(selectedShapes.size).toBe(0);
  });
});