import { render, fireEvent } from '@testing-library/svelte';
import { vi, describe, it, expect, beforeEach } from 'vitest';
import DrawingCanvas from './DrawingCanvas.svelte';
import { drawingStore } from '../lib/stores/drawing';
import { chainStore } from '../lib/stores/chains';
import { partStore } from '../lib/stores/parts';
import { pathStore } from '../lib/stores/paths';
import { operationsStore } from '../lib/stores/operations';
import { overlayStore } from '../lib/stores/overlay';
import { rapidStore } from '../lib/stores/rapids';
import { tessellationStore } from '../lib/stores/tessellation';
import type { Shape, Drawing } from '../types';
import type { ShapeChain } from '../lib/algorithms/chain-detection';
import type { Path } from '../lib/stores/paths';
import type { Rapid } from '../lib/algorithms/optimize-cut-order';

// Mock the geometry/nurbs module
vi.mock('../lib/geometry/nurbs', () => ({
  sampleNURBS: vi.fn(() => []),
  evaluateNURBS: vi.fn(() => ({ x: 0, y: 0 }))
}));

describe('DrawingCanvas - Simulation Page Path-Only Selection', () => {
  let mockDrawing: Drawing;
  let mockChains: ShapeChain[];
  let mockShapes: Shape[];
  let mockPaths: Path[];
  let mockRapids: Rapid[];

  beforeEach(() => {
    // Reset all stores
    drawingStore.clearDrawing();
    chainStore.clearChains();
    partStore.clearParts();
    pathStore.clearPaths();
    operationsStore.clearOperations();
    overlayStore.clearOverlays();
    rapidStore.clearRapids();
    tessellationStore.clearTessellation();

    // Create test shapes
    mockShapes = [
      {
        id: 'shape1',
        type: 'line',
        layer: '0',
        geometry: {
          start: { x: 0, y: 0 },
          end: { x: 10, y: 0 }
        }
      },
      {
        id: 'shape2', 
        type: 'line',
        layer: '0',
        geometry: {
          start: { x: 10, y: 0 },
          end: { x: 10, y: 10 }
        }
      },
      {
        id: 'shape3',
        type: 'line',
        layer: '0', 
        geometry: {
          start: { x: 20, y: 20 },
          end: { x: 30, y: 20 }
        }
      }
    ];

    mockDrawing = {
      id: 'test-drawing',
      fileName: 'test.dxf',
      units: 'mm',
      bounds: { minX: 0, minY: 0, maxX: 30, maxY: 30 },
      shapes: mockShapes
    };

    // Create chains
    mockChains = [
      {
        id: 'chain1',
        shapes: [mockShapes[0], mockShapes[1]].map(s => ({ ...s })),
        bounds: { minX: 0, minY: 0, maxX: 10, maxY: 10 }
      },
      {
        id: 'chain2', 
        shapes: [mockShapes[2]].map(s => ({ ...s })),
        bounds: { minX: 20, minY: 20, maxX: 30, maxY: 20 }
      }
    ];

    // Create paths (tool paths for cutting)
    mockPaths = [
      {
        id: 'path1',
        chainId: 'chain1',
        operationId: 'op1',
        enabled: true,
        order: 1,
        feedRate: 1000,
        cutHeight: 1.5,
        pierceHeight: 3.0,
        pierceDelay: 0.5,
        arcVoltage: 120,
        kerfWidth: 2.0,
        thcEnabled: true,
        leadInLength: 2.0,
        leadOutLength: 2.0,
        overcutLength: 0.5
      },
      {
        id: 'path2',
        chainId: 'chain2', 
        operationId: 'op1',
        enabled: true,
        order: 2,
        feedRate: 1000,
        cutHeight: 1.5,
        pierceHeight: 3.0,
        pierceDelay: 0.5,
        arcVoltage: 120,
        kerfWidth: 2.0,
        thcEnabled: true,
        leadInLength: 2.0,
        leadOutLength: 2.0,
        overcutLength: 0.5
      }
    ];

    // Create rapids (non-cutting movements between paths)
    mockRapids = [
      {
        id: 'rapid1',
        start: { x: 10, y: 10 },
        end: { x: 20, y: 20 },
        feedRate: 5000
      }
    ];

    // Load test data into stores
    drawingStore.loadDrawing(mockDrawing);
    chainStore.setChains(mockChains);
    pathStore.setPaths(mockPaths);
    rapidStore.setRapids(mockRapids);

    // Create a mock operation to enable paths
    operationsStore.addOperation({
      id: 'op1',
      name: 'Test Cut',
      enabled: true,
      targetType: 'chains',
      targetIds: ['chain1', 'chain2'],
      feedRate: 1000,
      cutHeight: 1.5,
      pierceHeight: 3.0,
      pierceDelay: 0.5,
      arcVoltage: 120,
      kerfWidth: 2.0,
      thcEnabled: true,
      leadInLength: 2.0,
      leadOutLength: 2.0,
      overcutLength: 0.5
    });
  });

  it('should only allow selecting entire paths (not individual shapes) on simulation page', async () => {
    const { container } = render(DrawingCanvas, {
      props: {
        treatChainsAsEntities: true, // Simulation should treat chains as path entities
        currentStage: 'simulate' as const,
        disableDragging: true,
        onChainClick: null // No chain click handler for simulation
      }
    });

    const canvas = container.querySelector('canvas') as HTMLCanvasElement;
    expect(canvas).toBeTruthy();

    // Click on shape1 (part of path1/chain1)
    await fireEvent.mouseDown(canvas, {
      button: 0,
      offsetX: 50, 
      offsetY: 400
    });

    // In simulation mode, should select the path, not individual shapes
    // The path selection should be handled by the path selection logic
    const selectedPathId = pathStore.getState().selectedPathId;
    expect(selectedPathId).toBe('path1');

    // Individual shape selection should not occur in simulation mode
    const selectedShapes = drawingStore.getState().selectedShapes;
    expect(selectedShapes.size).toBe(0); // No individual shapes should be selected
  });

  it('should allow selecting rapids on simulation page', async () => {
    const { container } = render(DrawingCanvas, {
      props: {
        treatChainsAsEntities: true,
        currentStage: 'simulate' as const,
        disableDragging: true,
        onChainClick: null
      }
    });

    const canvas = container.querySelector('canvas') as HTMLCanvasElement;

    // Click on rapid location (between the two chains)
    await fireEvent.mouseDown(canvas, {
      button: 0,
      offsetX: 150, // Rapid is from (10,10) to (20,20), click in middle area
      offsetY: 350
    });

    // Should select the rapid
    const selectedRapidId = rapidStore.getState().selectedRapidId;
    expect(selectedRapidId).toBe('rapid1');

    // Should not select individual shapes or paths
    const selectedShapes = drawingStore.getState().selectedShapes;
    const selectedPathId = pathStore.getState().selectedPathId;
    expect(selectedShapes.size).toBe(0);
    expect(selectedPathId).toBeNull();
  });

  it('should not allow individual shape hover/selection in simulation mode', async () => {
    const { container } = render(DrawingCanvas, {
      props: {
        treatChainsAsEntities: true,
        currentStage: 'simulate' as const,
        disableDragging: true,
        onChainClick: null
      }
    });

    const canvas = container.querySelector('canvas') as HTMLCanvasElement;

    // Hover over a shape
    await fireEvent.mouseMove(canvas, {
      offsetX: 50,
      offsetY: 400
    });

    // Wait for hover timeout
    await new Promise(resolve => setTimeout(resolve, 20));

    // In simulation mode, should not highlight individual shapes for selection
    // The hover behavior should be different from edit/program modes
    const hoveredShape = drawingStore.getState().hoveredShape;
    // In simulation mode, we should not set individual shape hover for selection purposes
    // (this test will fail until we implement the fix)
  });

  it('should prioritize rapid selection over path selection when both are near click point', async () => {
    const { container } = render(DrawingCanvas, {
      props: {
        treatChainsAsEntities: true,
        currentStage: 'simulate' as const,
        disableDragging: true,
        onChainClick: null
      }
    });

    const canvas = container.querySelector('canvas') as HTMLCanvasElement;

    // Click where rapid is located (rapids should have priority)
    await fireEvent.mouseDown(canvas, {
      button: 0,
      offsetX: 150,
      offsetY: 350
    });

    // Should select rapid, not path
    const selectedRapidId = rapidStore.getState().selectedRapidId;
    const selectedPathId = pathStore.getState().selectedPathId;
    
    expect(selectedRapidId).toBe('rapid1');
    expect(selectedPathId).toBeNull();
  });

  it('should deselect rapid when clicking on already selected rapid', async () => {
    const { container } = render(DrawingCanvas, {
      props: {
        treatChainsAsEntities: true,
        currentStage: 'simulate' as const,
        disableDragging: true,
        onChainClick: null
      }
    });

    const canvas = container.querySelector('canvas') as HTMLCanvasElement;

    // First click to select rapid
    await fireEvent.mouseDown(canvas, {
      button: 0,
      offsetX: 150,
      offsetY: 350
    });

    expect(rapidStore.getState().selectedRapidId).toBe('rapid1');

    // Second click on same rapid should deselect
    await fireEvent.mouseDown(canvas, {
      button: 0,
      offsetX: 150,
      offsetY: 350
    });

    expect(rapidStore.getState().selectedRapidId).toBeNull();
  });

  it('should not allow shape dragging in simulation mode', async () => {
    const { container } = render(DrawingCanvas, {
      props: {
        treatChainsAsEntities: true,
        currentStage: 'simulate' as const,
        disableDragging: true, // This should prevent dragging
        onChainClick: null
      }
    });

    const canvas = container.querySelector('canvas') as HTMLCanvasElement;

    // Get initial shape position
    const initialShape = mockShapes[0];
    const initialGeometry = initialShape.geometry as any;
    const initialStartX = initialGeometry.start.x;

    // Try to drag a shape
    await fireEvent.mouseDown(canvas, {
      button: 0,
      offsetX: 50,
      offsetY: 400
    });

    await fireEvent.mouseMove(canvas, {
      offsetX: 100, // Move right
      offsetY: 400
    });

    await fireEvent.mouseUp(canvas);

    // Shape should not have moved since dragging is disabled
    const currentShape = drawingStore.getState().drawing?.shapes.find(s => s.id === 'shape1');
    const currentGeometry = currentShape?.geometry as any;
    expect(currentGeometry.start.x).toBe(initialStartX);
  });
});