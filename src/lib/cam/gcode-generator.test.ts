import type { Arc } from '$lib/geometry/arc';
import { GeometryType } from '$lib/geometry/shape';
import { describe, expect, it } from 'vitest';
import type { Drawing, Shape, ToolPath } from '$lib/types';
import type { Spline } from '$lib/geometry/spline';
import { CutterCompensation, Unit } from '$lib/types';
import { generateGCode } from './gcode-generator';
import type { Circle } from '$lib/geometry/circle';

describe('generateGCode', () => {
    const mockDrawing: Drawing = {
        shapes: [],
        bounds: { min: { x: 0, y: 0 }, max: { x: 100, y: 100 } },
        units: Unit.MM,
    };

    const mockPath: ToolPath = {
        id: 'path1',
        shapeId: 'shape1',
        points: [
            { x: 0, y: 0 },
            { x: 100, y: 0 },
            { x: 100, y: 100 },
            { x: 0, y: 100 },
            { x: 0, y: 0 },
        ],
        leadIn: [
            { x: -5, y: 0 },
            { x: 0, y: 0 },
        ],
        leadOut: [
            { x: 0, y: 0 },
            { x: -5, y: 0 },
        ],
        isRapid: false,
        parameters: {
            feedRate: 1000,
            pierceHeight: 3.8,
            pierceDelay: 0.5,
            cutHeight: 1.5,
            kerf: 1.5,
            leadInLength: 5,
            leadOutLength: 5,
        },
    };

    it('should generate valid G-code header', () => {
        const gcode = generateGCode([mockPath], mockDrawing, {
            units: Unit.MM,
            safeZ: 10,
            rapidFeedRate: 5000,
            includeComments: true,
            cutterCompensation: CutterCompensation.OFF,
        });

        expect(gcode).toContain('G21'); // Metric units
        expect(gcode).toContain('G90'); // Absolute positioning
        expect(gcode).toContain('G64'); // Path blending for plasma
    });

    it('should generate plasma-specific commands', () => {
        const gcode = generateGCode([mockPath], mockDrawing, {
            units: Unit.MM,
            safeZ: 10,
            rapidFeedRate: 5000,
            includeComments: true,
            cutterCompensation: CutterCompensation.OFF,
        });

        expect(gcode).toContain('M3'); // Plasma on
        expect(gcode).toContain('M5'); // Plasma off
        expect(gcode).toContain('G4'); // Pierce delay
    });

    it('should include comments when requested', () => {
        const gcode = generateGCode([mockPath], mockDrawing, {
            units: Unit.MM,
            safeZ: 10,
            rapidFeedRate: 5000,
            includeComments: true,
            cutterCompensation: CutterCompensation.OFF,
        });

        expect(gcode).toContain(
            '(Generated by MetalHead CAM for LinuxCNC QtPlasmaC)'
        );
        expect(gcode).toContain('(Path 1)');
    });

    it('should not include comments when not requested', () => {
        const gcode = generateGCode([mockPath], mockDrawing, {
            units: Unit.MM,
            safeZ: 10,
            rapidFeedRate: 5000,
            includeComments: false,
            cutterCompensation: CutterCompensation.OFF,
        });

        expect(gcode).not.toContain(
            '(Generated by MetalHead CAM for LinuxCNC QtPlasmaC)'
        );
    });

    it('should handle imperial units', () => {
        const gcode = generateGCode([mockPath], mockDrawing, {
            units: Unit.INCH,
            safeZ: 0.5,
            rapidFeedRate: 200,
            includeComments: true,
            cutterCompensation: CutterCompensation.OFF,
        });

        expect(gcode).toContain('G20'); // Imperial units
    });

    describe('edge cases and advanced features', () => {
        it('should handle empty paths array', () => {
            const gcode = generateGCode([], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: false,
                cutterCompensation: CutterCompensation.OFF,
            });

            expect(gcode).toContain('G21'); // Should still have header
            expect(gcode).toContain('M2'); // Should still have footer
            expect(gcode).not.toContain('(Path 1)'); // No path comments
        });

        it('should handle rapid movements', () => {
            const rapidPath: ToolPath = {
                ...mockPath,
                id: 'rapid1',
                isRapid: true,
                parameters: undefined,
                leadIn: undefined,
                leadOut: undefined,
            };

            const gcode = generateGCode([rapidPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
            });

            // Current implementation treats rapids as regular paths but without parameters
            // This test verifies that it handles undefined parameters gracefully
            expect(gcode).toContain('G0'); // Should contain rapid moves
            expect(gcode).toContain('G1'); // Should contain linear moves for the path
        });

        it('should handle paths without lead-in/lead-out', () => {
            const simpleToolPath: ToolPath = {
                ...mockPath,
                leadIn: undefined,
                leadOut: undefined,
            };

            const gcode = generateGCode([simpleToolPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
            });

            expect(gcode).toContain('M3'); // Should still pierce
            expect(gcode).toContain('M5'); // Should still turn off
        });

        it('should handle material selection and THC features', () => {
            const gcode = generateGCode([mockPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
                materialNumber: 5,
                enableTHC: true,
                adaptiveFeedControl: true,
            });

            // With o=0 format, M190 and M66 are not used
            expect(gcode).toContain('(o=0'); // Material parameters in magic comment
            expect(gcode).toContain('M68 E3 Q0'); // Velocity control
            expect(gcode).toContain('M190 P-1'); // Return to default material
        });

        it('should disable velocity reduction when requested', () => {
            const gcode = generateGCode([mockPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
                adaptiveFeedControl: false,
            });

            expect(gcode).not.toContain('M68 E3'); // No velocity commands
            expect(gcode).not.toContain('M67 E3'); // No velocity reduction
        });

        it('should handle hole cutting with velocity reduction when enabled', () => {
            const holeToolPath: ToolPath = {
                ...mockPath,
                parameters: {
                    ...mockPath.parameters!,
                    isHole: true,
                    holeUnderspeedPercent: 60,
                },
            };

            const gcode = generateGCode([holeToolPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
                adaptiveFeedControl: true,
            });

            expect(gcode).toContain('M67 E3 Q60'); // Reduce velocity for hole
            expect(gcode).toContain('M67 E3 Q0'); // Reset velocity after hole
        });

        it('should not apply velocity reduction for holes when disabled', () => {
            const holeToolPath: ToolPath = {
                ...mockPath,
                parameters: {
                    ...mockPath.parameters!,
                    isHole: true,
                    holeUnderspeedPercent: undefined, // undefined means disabled
                },
            };

            const gcode = generateGCode([holeToolPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
                adaptiveFeedControl: true,
            });

            expect(gcode).not.toContain('M67 E3'); // No velocity commands at all
        });

        it('should not apply velocity reduction when set to 100%', () => {
            const holeToolPath: ToolPath = {
                ...mockPath,
                parameters: {
                    ...mockPath.parameters!,
                    isHole: true,
                    holeUnderspeedPercent: 100, // 100% means no underspeed
                },
            };

            const gcode = generateGCode([holeToolPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
                adaptiveFeedControl: true,
            });

            expect(gcode).not.toContain('M67 E3 Q100'); // No velocity commands for 100%
            expect(gcode).not.toContain('M67 E3 Q0'); // No reset needed
        });

        it('should use custom velocity percentage for holes', () => {
            const holeToolPath: ToolPath = {
                ...mockPath,
                parameters: {
                    ...mockPath.parameters!,
                    isHole: true,
                    holeUnderspeedPercent: 40,
                },
            };

            const gcode = generateGCode([holeToolPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
                adaptiveFeedControl: true,
            });

            expect(gcode).toContain('M67 E3 Q40'); // Use custom 40% velocity
            expect(gcode).toContain('M67 E3 Q0'); // Reset velocity after hole
        });

        it('should handle missing pierce parameters gracefully', () => {
            const pathWithoutParams: ToolPath = {
                ...mockPath,
                parameters: undefined,
            };

            const gcode = generateGCode([pathWithoutParams], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
            });

            // Should not crash and should include basic commands
            expect(gcode).toContain('G0'); // Rapid moves
            expect(gcode).toContain('G1'); // Linear moves
        });

        it('should handle native spline commands when enabled', () => {
            const splineShape: Shape = {
                id: 'spline1',
                type: GeometryType.SPLINE,
                layer: 'test',
                geometry: {
                    controlPoints: [
                        { x: 0, y: 0 },
                        { x: 10, y: 5 },
                        { x: 20, y: 0 },
                    ],
                    weights: [1, 1, 1],
                    knots: [0, 0, 0, 1, 1, 1],
                    degree: 2,
                } as Spline,
            };

            const splineToolPath: ToolPath = {
                ...mockPath,
                originalShape: splineShape,
            };

            const gcode = generateGCode([splineToolPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
                useNativeSplines: true,
            });

            expect(gcode).toContain('G5.2'); // NURBS start
            expect(gcode).toContain('G5.3'); // NURBS end
            expect(gcode).toContain('Native NURBS spline');
        });

        it('should handle native arc commands when enabled', () => {
            const arcShape: Shape = {
                id: 'arc1',
                type: GeometryType.ARC,
                layer: 'test',
                geometry: {
                    center: { x: 10, y: 10 },
                    radius: 5,
                    startAngle: 0,
                    endAngle: Math.PI / 2,
                    clockwise: false,
                } as Arc,
            };

            const arcToolPath: ToolPath = {
                ...mockPath,
                originalShape: arcShape,
            };

            const gcode = generateGCode([arcToolPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
                useNativeSplines: true,
            });

            expect(gcode).toContain('G3'); // Counterclockwise arc
            expect(gcode).toContain('Native arc command');
        });

        it('should handle native circle commands when enabled', () => {
            const circleShape: Shape = {
                id: 'circle1',
                type: GeometryType.CIRCLE,
                layer: 'test',
                geometry: {
                    center: { x: 10, y: 10 },
                    radius: 5,
                } as Circle,
            };

            const circleToolPath: ToolPath = {
                ...mockPath,
                originalShape: circleShape,
                executionClockwise: false, // Counterclockwise execution
            };

            const gcode = generateGCode([circleToolPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
                useNativeSplines: true,
            });

            expect(gcode).toContain('G3'); // Counterclockwise full circle
            expect(gcode).toContain('Native circle');
            expect(gcode).toContain('counterclockwise');
        });

        it('should handle native circle hole commands with correct direction', () => {
            const circleShape: Shape = {
                id: 'circle1',
                type: GeometryType.CIRCLE,
                layer: 'test',
                geometry: {
                    center: { x: 10, y: 10 },
                    radius: 5,
                } as Circle,
            };
            const holeToolPath: ToolPath = {
                ...mockPath,
                originalShape: circleShape,
                parameters: {
                    ...mockPath.parameters!,
                    isHole: true,
                },
                executionClockwise: true, // Clockwise execution for holes
            };
            const gcode = generateGCode([holeToolPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
                useNativeSplines: true,
            });

            expect(gcode).toContain('G2'); // Clockwise for holes
            expect(gcode).toContain('clockwise');
        });

        it('should handle incomplete spline data with fallback', () => {
            const incompleteSpline: Shape = {
                id: 'incomplete-spline',
                type: GeometryType.SPLINE,
                layer: 'test',
                geometry: {
                    controlPoints: [{ x: 0, y: 0 }], // Insufficient points
                    weights: [],
                    knots: [],
                    degree: 2,
                    fitPoints: [],
                    closed: false,
                } as Spline,
            };

            const splineToolPath: ToolPath = {
                ...mockPath,
                originalShape: incompleteSpline,
            };

            const gcode = generateGCode([splineToolPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
                useNativeSplines: true,
            });

            // With insufficient control points, the spline generation should return empty array
            // and fall back to using the points array from the ToolPath
            expect(gcode).not.toContain('G5.2'); // Should not use NURBS
            expect(gcode).toContain('G1'); // Should use linear moves instead
        });

        it('should format coordinates with proper precision', () => {
            const precisionPath: ToolPath = {
                ...mockPath,
                leadIn: undefined,
                leadOut: undefined,
                points: [
                    { x: 1.123456789, y: 2.987654321 },
                    { x: 10.000001, y: 20.999999 },
                ],
            };

            const gcode = generateGCode([precisionPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10.123456,
                rapidFeedRate: 5000,
                includeComments: false,
                cutterCompensation: CutterCompensation.OFF,
            });

            // Check that coordinates appear with proper precision somewhere in the output
            // The exact formatting depends on how the path is processed

            // Check Z coordinate precision (should be 3 decimal places for non-coordinates)
            expect(gcode).toContain('Z10.123');

            // Verify that coordinates exist in the output (may be processed differently)
            expect(gcode).toContain('X1.1235');
            expect(gcode).toContain('Y2.9877');
        });

        it('should handle QtPlasmaC-specific tool syntax', () => {
            const gcode = generateGCode([mockPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
            });

            expect(gcode).toContain('M3 $0'); // QtPlasmaC plasma on syntax
            expect(gcode).toContain('M5 $0'); // QtPlasmaC plasma off syntax
        });

        it('should generate proper HAL feed rate command', () => {
            const gcode = generateGCode([mockPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.OFF,
            });

            expect(gcode).toContain('F#<_hal[plasmac.cut-feed-rate]>'); // HAL feed rate
        });

        it('should not include plasma commands in non-plasma mode', () => {
            const gcode = generateGCode([mockPath], mockDrawing, {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: null,
            });

            expect(gcode).toContain('M3'); // Plasma on (always included)
            expect(gcode).toContain('M5'); // Plasma off (always included)
            expect(gcode).toContain('G4'); // Pierce delay (always included)
            // M190 is not used with o=0 format, material params are in magic comment
            expect(gcode).toContain('(o=0'); // Material parameters in magic comment
        });
    });
});
