import type { ToolPath, GCodeCommand, Drawing } from '../../types';

export interface GCodeOptions {
  units: 'mm' | 'inch';
  safeZ: number;
  rapidFeedRate: number;
  includeComments: boolean;
  plasmaMode: boolean;
}

export function generateGCode(
  paths: ToolPath[],
  drawing: Drawing,
  options: GCodeOptions
): string {
  const commands: GCodeCommand[] = [];
  
  // Header
  commands.push(...generateHeader(options));
  
  // Set units
  commands.push({
    code: options.units === 'mm' ? 'G21' : 'G20',
    parameters: {},
    comment: `Set units to ${options.units}`
  });
  
  // Absolute positioning
  commands.push({
    code: 'G90',
    parameters: {},
    comment: 'Absolute positioning'
  });
  
  // Process each tool path
  paths.forEach((path, index) => {
    commands.push(...generatePathCommands(path, options, index));
  });
  
  // Footer
  commands.push(...generateFooter(options));
  
  // Convert commands to string
  return commandsToString(commands, options);
}

function generateHeader(options: GCodeOptions): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  if (options.includeComments) {
    commands.push({
      code: '',
      parameters: {},
      comment: 'Generated by CAM-OCCT'
    });
    commands.push({
      code: '',
      parameters: {},
      comment: new Date().toISOString()
    });
  }
  
  // LinuxCNC specific initialization
  if (options.plasmaMode) {
    commands.push({
      code: 'G64',
      parameters: { P: 0.1 },
      comment: 'Path blending tolerance'
    });
  }
  
  return commands;
}

function generatePathCommands(
  path: ToolPath,
  options: GCodeOptions,
  index: number
): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  if (options.includeComments) {
    commands.push({
      code: '',
      parameters: {},
      comment: `Path ${index + 1}`
    });
  }
  
  // Move to safe height
  commands.push({
    code: 'G0',
    parameters: { Z: options.safeZ },
    comment: 'Move to safe height'
  });
  
  // Lead-in if present
  if (path.leadIn && path.leadIn.length > 0) {
    // Rapid to lead-in start
    const leadInStart = path.leadIn[0];
    commands.push({
      code: 'G0',
      parameters: { X: leadInStart.x, Y: leadInStart.y },
      comment: 'Move to lead-in start'
    });
    
    // Pierce if plasma mode
    if (options.plasmaMode && path.parameters) {
      commands.push(...generatePierceCommands(path.parameters));
    }
    
    // Cut lead-in
    path.leadIn.forEach((point, i) => {
      if (i > 0) {
        commands.push({
          code: 'G1',
          parameters: { 
            X: point.x, 
            Y: point.y,
            F: path.parameters?.feedRate || 1000
          }
        });
      }
    });
  } else {
    // Direct move to path start
    const start = path.points[0];
    commands.push({
      code: 'G0',
      parameters: { X: start.x, Y: start.y },
      comment: 'Move to path start'
    });
    
    if (options.plasmaMode && path.parameters) {
      commands.push(...generatePierceCommands(path.parameters));
    }
  }
  
  // Cut path
  path.points.forEach((point, i) => {
    if (i > 0) {
      commands.push({
        code: 'G1',
        parameters: { 
          X: point.x, 
          Y: point.y,
          F: path.parameters?.feedRate || 1000
        }
      });
    }
  });
  
  // Lead-out if present
  if (path.leadOut && path.leadOut.length > 0) {
    path.leadOut.forEach((point, i) => {
      if (i > 0) {
        commands.push({
          code: 'G1',
          parameters: { X: point.x, Y: point.y }
        });
      }
    });
  }
  
  // Turn off plasma
  if (options.plasmaMode) {
    commands.push({
      code: 'M5',
      parameters: {},
      comment: 'Plasma off'
    });
  }
  
  // Retract to safe height
  commands.push({
    code: 'G0',
    parameters: { Z: options.safeZ },
    comment: 'Retract to safe height'
  });
  
  return commands;
}

function generatePierceCommands(parameters: any): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  // Move to pierce height
  commands.push({
    code: 'G0',
    parameters: { Z: parameters.pierceHeight },
    comment: 'Move to pierce height'
  });
  
  // Turn on plasma
  commands.push({
    code: 'M3',
    parameters: { S: 1 },
    comment: 'Plasma on'
  });
  
  // Pierce delay
  commands.push({
    code: 'G4',
    parameters: { P: parameters.pierceDelay },
    comment: 'Pierce delay'
  });
  
  // Move to cut height
  commands.push({
    code: 'G1',
    parameters: { Z: parameters.cutHeight, F: 100 },
    comment: 'Move to cut height'
  });
  
  return commands;
}

function generateFooter(options: GCodeOptions): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  // Return to home
  commands.push({
    code: 'G0',
    parameters: { X: 0, Y: 0 },
    comment: 'Return to home'
  });
  
  // Program end
  commands.push({
    code: 'M2',
    parameters: {},
    comment: 'Program end'
  });
  
  return commands;
}

function commandsToString(commands: GCodeCommand[], options: GCodeOptions): string {
  return commands.map(cmd => {
    if (!cmd.code && cmd.comment) {
      return options.includeComments ? `(${cmd.comment})` : '';
    }
    
    let line = cmd.code;
    
    // Add parameters
    Object.entries(cmd.parameters).forEach(([key, value]) => {
      line += ` ${key}${value}`;
    });
    
    // Add comment
    if (options.includeComments && cmd.comment) {
      line += ` (${cmd.comment})`;
    }
    
    return line;
  }).filter(line => line).join('\n');
}