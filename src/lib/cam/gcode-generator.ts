import type { ToolPath, GCodeCommand, Drawing } from '../../types';

export interface GCodeOptions {
  units: 'mm' | 'inch';
  safeZ: number;
  rapidFeedRate: number;
  includeComments: boolean;
  plasmaMode: boolean;
  materialNumber?: number;
  enableTHC?: boolean;
  enableVelocityReduction?: boolean;
}

export function generateGCode(
  paths: ToolPath[],
  drawing: Drawing,
  options: GCodeOptions
): string {
  const commands: GCodeCommand[] = [];
  
  // Header
  commands.push(...generateHeader(options));
  
  // Set units
  commands.push({
    code: options.units === 'mm' ? 'G21' : 'G20',
    parameters: {},
    comment: `Set units to ${options.units}`
  });
  
  // Absolute positioning
  commands.push({
    code: 'G90',
    parameters: {},
    comment: 'Absolute positioning'
  });
  
  // Process each tool path
  paths.forEach((path, index) => {
    commands.push(...generatePathCommands(path, options, index));
  });
  
  // Footer
  commands.push(...generateFooter(options));
  
  // Convert commands to string
  return commandsToString(commands, options);
}

function generateHeader(options: GCodeOptions): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  if (options.includeComments) {
    commands.push({
      code: '',
      parameters: {},
      comment: 'Generated by CAM-OCCT for LinuxCNC QtPlasmaC'
    });
    commands.push({
      code: '',
      parameters: {},
      comment: new Date().toISOString()
    });
  }
  
  // QtPlasmaC preamble codes
  if (options.plasmaMode) {
    // Units setup
    commands.push({
      code: options.units === 'mm' ? 'G21' : 'G20',
      parameters: {},
      comment: `Set units to ${options.units === 'mm' ? 'millimeters' : 'inches'}`
    });
    
    // Cutter compensation off
    commands.push({
      code: 'G40',
      parameters: {},
      comment: 'Cutter compensation off'
    });
    
    // Tool length offset cancel
    commands.push({
      code: 'G49',
      parameters: {},
      comment: 'Tool length offset cancel'
    });
    
    // Path blending with tolerance
    const toleranceValue = options.units === 'mm' ? 0.1 : 0.004;
    commands.push({
      code: 'G64',
      parameters: { P: toleranceValue },
      comment: 'Path blending tolerance'
    });
    
    // Cancel canned cycles
    commands.push({
      code: 'G80',
      parameters: {},
      comment: 'Cancel canned cycles'
    });
    
    // Absolute positioning
    commands.push({
      code: 'G90',
      parameters: {},
      comment: 'Absolute positioning'
    });
    
    // Cancel coordinate system offsets
    commands.push({
      code: 'G92.1',
      parameters: {},
      comment: 'Cancel coordinate system offsets'  
    });
    
    // Feed per minute mode
    commands.push({
      code: 'G94',
      parameters: {},
      comment: 'Feed per minute mode'
    });
    
    // Constant surface speed off
    commands.push({
      code: 'G97',
      parameters: {},
      comment: 'Constant surface speed off'
    });
    
    // Enable paused motion (adaptive feed control)
    commands.push({
      code: 'M52',
      parameters: { P: 1 },
      comment: 'Enable paused motion for THC'
    });
    
    // Reset velocity reduction to 100%
    if (options.enableVelocityReduction !== false) {
      commands.push({
        code: 'M68',
        parameters: { E: 3, Q: 0 },
        comment: 'Set velocity to 100%'
      });
    }
    
    // Material selection if specified
    if (options.materialNumber !== undefined && options.materialNumber >= 0) {
      commands.push({
        code: 'M190',
        parameters: { P: options.materialNumber },
        comment: `Select material ${options.materialNumber}`
      });
      
      commands.push({
        code: 'M66',
        parameters: { P: 3, L: 3, Q: 1 },
        comment: 'Wait for material change confirmation'
      });
    }
    
    // Use material feed rate from HAL
    commands.push({
      code: 'F#<_hal[plasmac.cut-feed-rate]>',
      parameters: {},
      comment: 'Use material feed rate from HAL'
    });
  }
  
  return commands;
}

function generatePathCommands(
  path: ToolPath,
  options: GCodeOptions,
  index: number
): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  if (options.includeComments) {
    commands.push({
      code: '',
      parameters: {},
      comment: `Path ${index + 1}`
    });
  }
  
  // Move to safe height
  commands.push({
    code: 'G0',
    parameters: { Z: options.safeZ },
    comment: 'Move to safe height'
  });
  
  // Lead-in if present
  if (path.leadIn && path.leadIn.length > 0) {
    // Rapid to lead-in start
    const leadInStart = path.leadIn[0];
    commands.push({
      code: 'G0',
      parameters: { X: leadInStart.x, Y: leadInStart.y },
      comment: 'Move to lead-in start'
    });
    
    // Pierce if plasma mode
    if (options.plasmaMode && path.parameters) {
      commands.push(...generatePierceCommands(path.parameters, options));
    }
    
    // Cut lead-in
    path.leadIn.forEach((point, i) => {
      if (i > 0) {
        commands.push({
          code: 'G1',
          parameters: { 
            X: point.x, 
            Y: point.y
            // Note: Using HAL feed rate, not explicit F parameter
          }
        });
      }
    });
  } else {
    // Direct move to path start
    const start = path.points[0];
    commands.push({
      code: 'G0',
      parameters: { X: start.x, Y: start.y },
      comment: 'Move to path start'
    });
    
    if (options.plasmaMode && path.parameters) {
      commands.push(...generatePierceCommands(path.parameters, options));
    }
  }
  
  // Detect if this is a hole (closed path with small area for velocity reduction)
  const isHole = (path.points.length > 3 && 
    Math.abs(path.points[0].x - path.points[path.points.length - 1].x) < 0.1 &&
    Math.abs(path.points[0].y - path.points[path.points.length - 1].y) < 0.1);
  
  // Apply velocity reduction for hole cutting
  if (options.plasmaMode && isHole && options.enableVelocityReduction !== false) {
    commands.push({
      code: 'M67',
      parameters: { E: 3, Q: 60 },
      comment: 'Reduce velocity to 60% for hole cutting'
    });
  }
  
  // Cut path
  path.points.forEach((point, i) => {
    if (i > 0) {
      commands.push({
        code: 'G1',
        parameters: { 
          X: point.x, 
          Y: point.y
          // Note: Using HAL feed rate, not explicit F parameter
        }
      });
    }
  });
  
  // Reset velocity after hole cutting
  if (options.plasmaMode && isHole && options.enableVelocityReduction !== false) {
    commands.push({
      code: 'M67',
      parameters: { E: 3, Q: 0 },
      comment: 'Reset velocity to 100%'
    });
  }
  
  // Lead-out if present
  if (path.leadOut && path.leadOut.length > 0) {
    path.leadOut.forEach((point, i) => {
      if (i > 0) {
        commands.push({
          code: 'G1',
          parameters: { X: point.x, Y: point.y }
        });
      }
    });
  }
  
  // Turn off plasma using QtPlasmaC syntax
  if (options.plasmaMode) {
    commands.push({
      code: 'M5',
      parameters: { '$0': '' },
      comment: 'Plasma torch off'
    });
  }
  
  // Retract to safe height
  commands.push({
    code: 'G0',
    parameters: { Z: options.safeZ },
    comment: 'Retract to safe height'
  });
  
  return commands;
}

function generatePierceCommands(parameters: any, options: GCodeOptions): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  // Move to pierce height
  commands.push({
    code: 'G0',
    parameters: { Z: parameters.pierceHeight },
    comment: 'Move to pierce height'
  });
  
  // Turn on plasma using QtPlasmaC syntax
  commands.push({
    code: 'M3',
    parameters: { '$0': '', S: 1 },
    comment: 'Plasma torch on'
  });
  
  // Pierce delay (QtPlasmaC handles this automatically based on material)
  // But we can still add explicit delay if needed
  if (parameters.pierceDelay && parameters.pierceDelay > 0) {
    commands.push({
      code: 'G4',
      parameters: { P: parameters.pierceDelay },
      comment: 'Pierce delay'
    });
  }
  
  // Move to cut height
  commands.push({
    code: 'G1',
    parameters: { Z: parameters.cutHeight, F: 100 },
    comment: 'Move to cut height'
  });
  
  return commands;
}

function generateFooter(options: GCodeOptions): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  // Reset velocity reduction to 100% (recommended for postamble)
  if (options.plasmaMode && options.enableVelocityReduction !== false) {
    commands.push({
      code: 'M68',
      parameters: { E: 3, Q: 0 },
      comment: 'Reset velocity to 100%'
    });
  }
  
  // Return to material default if material was selected
  if (options.plasmaMode && options.materialNumber !== undefined && options.materialNumber >= 0) {
    commands.push({
      code: 'M190',
      parameters: { P: -1 },
      comment: 'Return to default material'
    });
  }
  
  // Return to home
  commands.push({
    code: 'G0',
    parameters: { X: 0, Y: 0 },
    comment: 'Return to home'
  });
  
  // Program end
  commands.push({
    code: 'M2',
    parameters: {},
    comment: 'Program end'
  });
  
  return commands;
}

function commandsToString(commands: GCodeCommand[], options: GCodeOptions): string {
  return commands.map(cmd => {
    if (!cmd.code && cmd.comment) {
      return options.includeComments ? `(${cmd.comment})` : '';
    }
    
    let line = cmd.code;
    
    // Add parameters
    Object.entries(cmd.parameters).forEach(([key, value]) => {
      if (key.startsWith('$')) {
        // QtPlasmaC tool syntax (e.g., $0, $1, $2)
        line += ` ${key}`;
      } else {
        // Standard parameter syntax
        line += ` ${key}${value}`;
      }
    });
    
    // Add comment
    if (options.includeComments && cmd.comment) {
      line += ` (${cmd.comment})`;
    }
    
    return line;
  }).filter(line => line).join('\n');
}