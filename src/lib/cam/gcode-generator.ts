import type { ToolPath, GCodeCommand, Drawing, Shape, Spline, Arc, Circle, CuttingParameters, Point2D } from '../../lib/types';

export interface GCodeOptions {
  units: 'mm' | 'inch';
  safeZ: number;
  rapidFeedRate: number;
  includeComments: boolean;
  plasmaMode: boolean;
  materialNumber?: number;
  enableTHC?: boolean;
  enableVelocityReduction?: boolean;
  useNativeSplines?: boolean; // Enable LinuxCNC G5.1/G5.2 spline commands
}

export function generateGCode(
  paths: ToolPath[],
  drawing: Drawing,
  options: GCodeOptions
): string {
  const commands: GCodeCommand[] = [];
  
  // Header
  commands.push(...generateHeader(options));
  
  // Set units
  commands.push({
    code: options.units === 'mm' ? 'G21' : 'G20',
    parameters: {},
    comment: `Set units to ${options.units}`
  });
  
  // Absolute positioning
  commands.push({
    code: 'G90',
    parameters: {},
    comment: 'Absolute positioning'
  });
  
  // Process each tool path
  paths.forEach((path, index) => {
    commands.push(...generatePathCommands(path, options, index));
  });
  
  // Footer
  commands.push(...generateFooter(options));
  
  // Convert commands to string
  return commandsToString(commands, options);
}

function generateHeader(options: GCodeOptions): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  if (options.includeComments) {
    commands.push({
      code: '',
      parameters: {},
      comment: 'Generated by CAM-OCCT for LinuxCNC QtPlasmaC'
    });
    commands.push({
      code: '',
      parameters: {},
      comment: new Date().toISOString()
    });
  }
  
  // QtPlasmaC preamble codes
  if (options.plasmaMode) {
    // Units setup
    commands.push({
      code: options.units === 'mm' ? 'G21' : 'G20',
      parameters: {},
      comment: `Set units to ${options.units === 'mm' ? 'millimeters' : 'inches'}`
    });
    
    // Cutter compensation off
    commands.push({
      code: 'G40',
      parameters: {},
      comment: 'Cutter compensation off'
    });
    
    // Tool length offset cancel
    commands.push({
      code: 'G49',
      parameters: {},
      comment: 'Tool length offset cancel'
    });
    
    // Path blending with tolerance
    const toleranceValue: number = options.units === 'mm' ? 0.1 : 0.004;
    commands.push({
      code: 'G64',
      parameters: { P: toleranceValue },
      comment: 'Path blending tolerance'
    });
    
    // Cancel canned cycles
    commands.push({
      code: 'G80',
      parameters: {},
      comment: 'Cancel canned cycles'
    });
    
    // Absolute positioning
    commands.push({
      code: 'G90',
      parameters: {},
      comment: 'Absolute positioning'
    });
    
    // Cancel coordinate system offsets
    commands.push({
      code: 'G92.1',
      parameters: {},
      comment: 'Cancel coordinate system offsets'  
    });
    
    // Feed per minute mode
    commands.push({
      code: 'G94',
      parameters: {},
      comment: 'Feed per minute mode'
    });
    
    // Constant surface speed off
    commands.push({
      code: 'G97',
      parameters: {},
      comment: 'Constant surface speed off'
    });
    
    // Enable paused motion (adaptive feed control)
    commands.push({
      code: 'M52',
      parameters: { P: 1 },
      comment: 'Enable paused motion for THC'
    });
    
    // Reset velocity reduction to 100%
    if (options.enableVelocityReduction !== false) {
      commands.push({
        code: 'M68',
        parameters: { E: 3, Q: 0 },
        comment: 'Set velocity to 100%'
      });
    }
    
    // Material selection if specified
    if (options.materialNumber !== undefined && options.materialNumber >= 0) {
      commands.push({
        code: 'M190',
        parameters: { P: options.materialNumber },
        comment: `Select material ${options.materialNumber}`
      });
      
      commands.push({
        code: 'M66',
        parameters: { P: 3, L: 3, Q: 1 },
        comment: 'Wait for material change confirmation'
      });
    }
    
    // Use material feed rate from HAL
    commands.push({
      code: 'F#<_hal[plasmac.cut-feed-rate]>',
      parameters: {},
      comment: 'Use material feed rate from HAL'
    });
  }
  
  return commands;
}

function generatePathCommands(
  path: ToolPath,
  options: GCodeOptions,
  index: number
): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  if (options.includeComments) {
    commands.push({
      code: '',
      parameters: {},
      comment: `Path ${index + 1}`
    });
  }
  
  // Move to safe height
  commands.push({
    code: 'G0',
    parameters: { Z: options.safeZ },
    comment: 'Move to safe height'
  });
  
  // Lead-in if present
  if (path.leadIn && path.leadIn.length > 0) {
    // Rapid to lead-in start
    const leadInStart: { x: number; y: number } = path.leadIn[0];
    commands.push({
      code: 'G0',
      parameters: { X: leadInStart.x, Y: leadInStart.y },
      comment: 'Move to lead-in start'
    });
    
    // Pierce if plasma mode
    if (options.plasmaMode && path.parameters) {
      commands.push(...generatePierceCommands(path.parameters));
    }
    
    // Cut lead-in
    path.leadIn.forEach((point, i) => {
      if (i > 0) {
        commands.push({
          code: 'G1',
          parameters: { 
            X: point.x, 
            Y: point.y
            // Note: Using HAL feed rate, not explicit F parameter
          }
        });
      }
    });
  } else {
    // Direct move to path start
    const pathPoints: { x: number; y: number }[] = path.points || [];
    const start: { x: number; y: number } = pathPoints[0];
    commands.push({
      code: 'G0',
      parameters: { X: start.x, Y: start.y },
      comment: 'Move to path start'
    });
    
    if (options.plasmaMode && path.parameters) {
      commands.push(...generatePierceCommands(path.parameters));
    }
  }
  
  // Detect if this is a hole (closed path with small area for velocity reduction)
  const pathPoints: { x: number; y: number }[] = path.points || [];
  const isHole: boolean = (pathPoints.length > 3 && 
    Math.abs(pathPoints[0].x - pathPoints[pathPoints.length - 1].x) < 0.1 &&
    Math.abs(pathPoints[0].y - pathPoints[pathPoints.length - 1].y) < 0.1);
  
  // Apply velocity reduction for hole cutting
  if (options.plasmaMode && isHole && options.enableVelocityReduction !== false) {
    commands.push({
      code: 'M67',
      parameters: { E: 3, Q: 60 },
      comment: 'Reduce velocity to 60% for hole cutting'
    });
  }
  
  // Cut path - use native splines if enabled and available
  if (options.useNativeSplines && path.originalShape) {
    commands.push(...generateNativeSplineCommands(path.originalShape, options));
  } else {
    // Fallback to linear interpolation
    const pathPoints: { x: number; y: number }[] = path.points || [];
    pathPoints.forEach((point, i) => {
      if (i > 0) {
        commands.push({
          code: 'G1',
          parameters: { 
            X: point.x, 
            Y: point.y
            // Note: Using HAL feed rate, not explicit F parameter
          }
        });
      }
    });
  }
  
  // Reset velocity after hole cutting
  if (options.plasmaMode && isHole && options.enableVelocityReduction !== false) {
    commands.push({
      code: 'M67',
      parameters: { E: 3, Q: 0 },
      comment: 'Reset velocity to 100%'
    });
  }
  
  // Lead-out if present
  if (path.leadOut && path.leadOut.length > 0) {
    path.leadOut.forEach((point, i) => {
      if (i > 0) {
        commands.push({
          code: 'G1',
          parameters: { X: point.x, Y: point.y }
        });
      }
    });
  }
  
  // Turn off plasma using QtPlasmaC syntax
  if (options.plasmaMode) {
    commands.push({
      code: 'M5',
      parameters: { '$0': '' },
      comment: 'Plasma torch off'
    });
  }
  
  // Retract to safe height
  commands.push({
    code: 'G0',
    parameters: { Z: options.safeZ },
    comment: 'Retract to safe height'
  });
  
  return commands;
}

function generatePierceCommands(parameters: CuttingParameters): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  // Move to pierce height
  commands.push({
    code: 'G0',
    parameters: { Z: parameters.pierceHeight },
    comment: 'Move to pierce height'
  });
  
  // Turn on plasma using QtPlasmaC syntax
  commands.push({
    code: 'M3',
    parameters: { '$0': '', S: 1 },
    comment: 'Plasma torch on'
  });
  
  // Pierce delay (QtPlasmaC handles this automatically based on material)
  // But we can still add explicit delay if needed
  if (parameters.pierceDelay && parameters.pierceDelay > 0) {
    commands.push({
      code: 'G4',
      parameters: { P: parameters.pierceDelay },
      comment: 'Pierce delay'
    });
  }
  
  // Move to cut height
  commands.push({
    code: 'G1',
    parameters: { Z: parameters.cutHeight, F: 100 },
    comment: 'Move to cut height'
  });
  
  return commands;
}

function generateFooter(options: GCodeOptions): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  // Reset velocity reduction to 100% (recommended for postamble)
  if (options.plasmaMode && options.enableVelocityReduction !== false) {
    commands.push({
      code: 'M68',
      parameters: { E: 3, Q: 0 },
      comment: 'Reset velocity to 100%'
    });
  }
  
  // Return to material default if material was selected
  if (options.plasmaMode && options.materialNumber !== undefined && options.materialNumber >= 0) {
    commands.push({
      code: 'M190',
      parameters: { P: -1 },
      comment: 'Return to default material'
    });
  }
  
  // Return to home
  commands.push({
    code: 'G0',
    parameters: { X: 0, Y: 0 },
    comment: 'Return to home'
  });
  
  // Program end
  commands.push({
    code: 'M2',
    parameters: {},
    comment: 'Program end'
  });
  
  return commands;
}

function generateNativeSplineCommands(shape: Shape, options: GCodeOptions): GCodeCommand[] {
  const commands: GCodeCommand[] = [];
  
  switch (shape.type) {
    case 'spline':
      const spline: import("$lib/types/geometry").Spline = shape.geometry as Spline;
      
      // Use G5.2/G5.3 NURBS commands for splines
      if (spline.controlPoints && spline.controlPoints.length >= 2) {
        if (options.includeComments) {
          commands.push({
            code: '',
            parameters: {},
            comment: 'Native NURBS spline (G5.2/G5.3)'
          });
        }
        
        // G5.2 - Open NURBS data block
        const order: number = spline.degree || 3;
        commands.push({
          code: 'G5.2',
          parameters: { 
            P: spline.weights && spline.weights[0] ? spline.weights[0] : 1, 
            L: order 
          },
          comment: 'Start NURBS block'
        });
        
        // Add control points with weights
        spline.controlPoints.forEach((point: Point2D, i: number) => {
          if (i > 0) { // Skip first point (already at start position)
            const weight: number = spline.weights && spline.weights[i] ? spline.weights[i] : 1;
            commands.push({
              code: '',
              parameters: { 
                X: point.x, 
                Y: point.y, 
                P: weight 
              }
            });
          }
        });
        
        // G5.3 - Close NURBS data block
        commands.push({
          code: 'G5.3',
          parameters: {},
          comment: 'End NURBS block'
        });
      } else {
        // Fallback: convert to linear segments if spline data is incomplete
        if (options.includeComments) {
          commands.push({
            code: '',
            parameters: {},
            comment: 'Spline fallback to linear segments (incomplete NURBS data)'
          });
        }
        // This would use the existing points array from the ToolPath
        return [];
      }
      break;
      
    case 'arc':
      // Use native arc commands (G2/G3) for arcs
      const arc: import("$lib/types/geometry").Arc = shape.geometry as Arc;
      if (options.includeComments) {
        commands.push({
          code: '',
          parameters: {},
          comment: 'Native arc command'
        });
      }
      
      // Calculate arc endpoint
      const endX: number = arc.center.x + arc.radius * Math.cos(arc.endAngle);
      const endY: number = arc.center.y + arc.radius * Math.sin(arc.endAngle);
      
      // Calculate center offsets from start point
      const startX: number = arc.center.x + arc.radius * Math.cos(arc.startAngle);
      const startY: number = arc.center.y + arc.radius * Math.sin(arc.startAngle);
      const I: number = arc.center.x - startX;
      const J: number = arc.center.y - startY;
      
      // Determine direction (clockwise vs counterclockwise)
      const isClockwise: boolean = (arc.endAngle - arc.startAngle) < 0;
      
      commands.push({
        code: isClockwise ? 'G2' : 'G3',
        parameters: { 
          X: endX, 
          Y: endY, 
          I: I, 
          J: J 
        },
        comment: `${isClockwise ? 'Clockwise' : 'Counterclockwise'} arc`
      });
      break;
      
    case 'circle':
      // Convert full circles to arc commands
      const circle: import("$lib/types/geometry").Circle = shape.geometry as Circle;
      if (options.includeComments) {
        commands.push({
          code: '',
          parameters: {},
          comment: 'Native circle (full arc)'
        });
      }
      
      // Full circle as 360-degree arc
      commands.push({
        code: 'G2', // Clockwise full circle
        parameters: { 
          X: circle.center.x + circle.radius, 
          Y: circle.center.y, 
          I: -circle.radius, 
          J: 0 
        },
        comment: 'Full circle'
      });
      break;
      
    default:
      // For other shapes (line, polyline, ellipse), return empty array to use linear fallback
      return [];
  }
  
  return commands;
}

function commandsToString(commands: GCodeCommand[], options: GCodeOptions): string {
  return commands.map(cmd => {
    if (!cmd.code && cmd.comment) {
      return options.includeComments ? `(${cmd.comment})` : '';
    }
    
    let line: string = cmd.code;
    
    // Add parameters
    Object.entries(cmd.parameters).forEach(([key, value]) => {
      if (key.startsWith('$')) {
        // QtPlasmaC tool syntax (e.g., $0, $1, $2)
        line += ` ${key}`;
      } else {
        // Format numeric values with appropriate precision
        let formattedValue: string | number = value;
        if (typeof value === 'number') {
          // Use 4 decimal places for coordinates, 3 for other values
          const isCoordinate: boolean = ['X', 'Y', 'Z', 'I', 'J', 'K'].includes(key);
          const precision: number = isCoordinate ? 4 : 3;
          formattedValue = Number(value.toFixed(precision));
        }
        // Standard parameter syntax
        line += ` ${key}${formattedValue}`;
      }
    });
    
    // Add comment
    if (options.includeComments && cmd.comment) {
      line += ` (${cmd.comment})`;
    }
    
    return line;
  }).filter(line => line).join('\n');
}