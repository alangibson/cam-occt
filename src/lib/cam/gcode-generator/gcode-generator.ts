import type { Unit } from '$lib/config/units/units';
import type { DrawingData } from '$lib/cam/drawing/interfaces';
import type { ShapeData } from '$lib/geometry/shape/interfaces';
import type { Arc } from '$lib/geometry/arc/interfaces';
import type { Circle } from '$lib/geometry/circle/interfaces';
import type { Point2D } from '$lib/geometry/point/interfaces';
import type { Spline } from '$lib/geometry/spline/interfaces';
import { GeometryType } from '$lib/geometry/shape/enums';
import { DEFAULT_SPLINE_DEGREE } from '$lib/geometry/spline/constants';
import {
    DEFAULT_CUT_HEIGHT_MM,
    DEFAULT_PIERCE_DELAY,
    DEFAULT_PIERCE_HEIGHT_MM,
    GCODE_COORDINATE_PRECISION,
    GCODE_PARAMETER_PRECISION,
    IMPERIAL_FEED_RATE_MM,
} from '$lib/cam/constants';
import { CutterCompensation } from '$lib/cam/cut-generator/enums';
import type { CutPath } from '$lib/cam/cut-generator/interfaces';
import type { CuttingParameters, GCodeCommand } from './interfaces';
import { NormalSide } from '$lib/cam/cut/enums';

/**
 * G-code path blending tolerance for metric units (mm)
 */
const GCODE_TOLERANCE_MM = 0.1;

/**
 * G-code path blending tolerance for imperial units (inches)
 */
const GCODE_TOLERANCE_INCHES = 0.004;

interface GCodeOptions {
    units: Unit;
    safeZ: number;
    rapidFeedRate: number;
    includeComments: boolean;
    cutterCompensation: CutterCompensation | null;
    materialNumber?: number;
    adaptiveFeedControl?: boolean | null; // M52 commands for adaptive feed control
    enableTHC?: boolean | null; // M65/M64 P2 commands for THC enable/disable
    useNativeSplines?: boolean; // Enable LinuxCNC G5.1/G5.2 spline commands
}

export function generateGCode(
    cuts: CutPath[],
    drawing: DrawingData,
    options: GCodeOptions
): string {
    const commands: GCodeCommand[] = [];

    // Header
    commands.push(...generateHeader(options));

    // Process each tool cut
    cuts.forEach((cut, index) => {
        // Create/update temporary material if cut has cutting parameters
        if (cut.parameters) {
            const materialCommands = generateTemporaryMaterial(cut.parameters);
            commands.push(...materialCommands);
        }

        commands.push(...generateCutCommands(cut, options, index));
    });

    // Footer
    commands.push(...generateFooter(options));

    // Convert commands to string
    return commandsToString(commands, options);
}

/**
 * QtPlasmaC preamble codes (always in plasma mode)
 */
function generateHeader(options: GCodeOptions): GCodeCommand[] {
    const commands: GCodeCommand[] = [];

    if (options.includeComments) {
        commands.push({
            code: '',
            parameters: {},
            comment: 'Generated by MetalHead CAM for LinuxCNC QtPlasmaC',
        });
        commands.push({
            code: '',
            parameters: {},
            comment: new Date().toISOString(),
        });
    }

    // Units setup
    commands.push({
        code: options.units === 'mm' ? 'G21' : 'G20',
        parameters: {},
        comment: `Set units to ${options.units === 'mm' ? 'millimeters' : 'inches'}`,
    });

    // Cutter compensation off
    // Always set G40 at start to ensure clean state
    commands.push({
        code: 'G40',
        parameters: {},
        comment: 'Cutter compensation off',
    });

    // Tool length offset cancel
    //
    // Can set tool length with G43, but must be off for PlasmaC
    commands.push({
        code: 'G49',
        parameters: {},
        comment: 'Tool length offset cancel',
    });

    // Path blending with tolerance
    //
    // TODO There are many additional settings possible
    const toleranceValue: number =
        options.units === 'mm' ? GCODE_TOLERANCE_MM : GCODE_TOLERANCE_INCHES;
    commands.push({
        code: 'G64',
        parameters: { P: toleranceValue },
        comment: 'Path blending tolerance',
    });

    // Cancel canned cycles
    commands.push({
        code: 'G80',
        parameters: {},
        comment: 'Cancel canned cycles',
    });

    // Absolute positioning
    //
    // Also G91 = incremental distance mode
    commands.push({
        code: 'G90',
        parameters: {},
        comment: 'Absolute positioning',
    });

    // Cancel coordinate system offsets
    commands.push({
        code: 'G92.1',
        parameters: {},
        comment: 'Cancel coordinate system offsets',
    });

    // Feed per minute mode
    commands.push({
        code: 'G94',
        parameters: {},
        comment: 'Feed per minute mode',
    });

    // Constant surface speed off
    commands.push({
        code: 'G97',
        parameters: {},
        comment: 'Constant surface speed off',
    });

    // Enable paused motion (adaptive feed control)
    if (options.adaptiveFeedControl === true) {
        commands.push({
            code: 'M52',
            parameters: { P: 1 },
            comment: 'Enable paused motion for adaptive feed control',
        });
    } else if (options.adaptiveFeedControl === false) {
        commands.push({
            code: 'M52',
            parameters: { P: 0 },
            comment: 'Disable paused motion',
        });
    }
    // If adaptiveFeedControl is null, no M52 command is generated

    // THC enable/disable control
    if (options.enableTHC === true) {
        commands.push({
            code: 'M65',
            parameters: { P: 2 },
            comment: 'Enable THC',
        });
    } else if (options.enableTHC === false) {
        commands.push({
            code: 'M64',
            parameters: { P: 2 },
            comment: 'Disable THC',
        });
    }
    // If enableTHC is null, no M65/M64 command is generated

    // Reset velocity reduction to 100%
    if (options.adaptiveFeedControl !== false) {
        commands.push({
            code: 'M68',
            parameters: { E: 3, Q: 0 },
            comment: 'Set velocity to 100%',
        });
    }

    // We don't have Materials yet, so we'll create a temporary ones
    // on the fly outside of the header
    //
    // Material selection if specified
    // if (options.materialNumber !== undefined && options.materialNumber >= 0) {
    //   commands.push({
    //     code: "M190",
    //     parameters: { P: options.materialNumber },
    //     comment: `Select material ${options.materialNumber}`,
    //   });
    //
    //   commands.push({
    //     code: "M66",
    //     parameters: { P: 3, L: 3, Q: 1 },
    //     comment: "Wait for material change confirmation",
    //   });
    // }

    // Use material feed rate from HAL
    commands.push({
        code: 'F#<_hal[plasmac.cut-feed-rate]>',
        parameters: {},
        comment: 'Use material feed rate from HAL',
    });

    return commands;
}

/**
 * Generate temporary material using QtPlasmaC magic comments
 */
function generateTemporaryMaterial(
    parameters: CuttingParameters
): GCodeCommand[] {
    const commands: GCodeCommand[] = [];

    // Build the magic comment for temporary material
    let magicComment = 'o=0';

    // TODO not required for o=0
    // magicComment += `, nu=${materialNumber}`;

    // Add material name if available
    // TODO not required for o=0
    // if (parameters.toolName) {
    //   magicComment += `, na=${parameters.toolName}`;
    // } else {
    //   magicComment += `, na=Temp Material ${materialNumber}`;
    // }

    // Mandatory parameters
    magicComment += `, ph=${parameters.pierceHeight || DEFAULT_PIERCE_HEIGHT_MM}`; // Pierce height
    magicComment += `, pd=${parameters.pierceDelay || DEFAULT_PIERCE_DELAY}`; // Pierce delay
    magicComment += `, ch=${parameters.cutHeight || DEFAULT_CUT_HEIGHT_MM}`; // Cut height
    magicComment += `, fr=${parameters.feedRate || IMPERIAL_FEED_RATE_MM}`; // Feed rate

    // Optional parameters
    if (parameters.kerfWidth !== undefined) {
        magicComment += `, kw=${parameters.kerfWidth}`;
    }

    // THC enable/disable (0=off, 1=on)
    if (parameters.enableTHC !== undefined) {
        magicComment += `, th=${parameters.enableTHC ? 1 : 0}`;
    }

    if (parameters.cutAmps !== undefined) {
        magicComment += `, ca=${parameters.cutAmps}`;
    }

    if (parameters.cutVolts !== undefined) {
        magicComment += `, cv=${parameters.cutVolts}`;
    }

    if (parameters.pauseAtEnd !== undefined) {
        magicComment += `, pe=${parameters.pauseAtEnd}`;
    }

    if (parameters.cutMode !== undefined) {
        magicComment += `, cm=${parameters.cutMode}`;
    }

    if (parameters.gasPresure !== undefined) {
        magicComment += `, gp=${parameters.gasPresure}`;
    }

    if (parameters.torchEnable !== undefined) {
        magicComment += `, te=${parameters.torchEnable ? 1 : 0}`;
    }

    // Add the magic comment as a regular comment command
    commands.push({
        code: '',
        parameters: {},
        comment: magicComment,
    });

    // Select the temporary material
    // TODO we use temporary materials
    // commands.push({
    //   code: "M190",
    //   parameters: { P: materialNumber },
    //   comment: `Select temporary material ${materialNumber}`
    // });

    // Wait for material change confirmation
    // TODO we use temporary materials
    // commands.push({
    //   code: "M66",
    //   parameters: { P: 3, L: 3, Q: 1 },
    //   comment: "Wait for material change confirmation"
    // });

    // Set the feed rate explicitly
    // TODO this is done with F#<_hal[plasmac.cut-feed-rate]>
    // if (parameters.feedRate) {
    //   commands.push({
    //     code: "F",
    //     parameters: {},
    //     comment: `Set feed rate to ${parameters.feedRate}`,
    //     rawValue: parameters.feedRate
    //   });
    // }

    return commands;
}

function generateCutCommands(
    cut: CutPath,
    options: GCodeOptions,
    index: number
): GCodeCommand[] {
    const commands: GCodeCommand[] = [];

    if (options.includeComments) {
        commands.push({
            code: '',
            parameters: {},
            comment: `Cut ${index + 1}`,
        });
    }

    // Move to safe height
    commands.push({
        code: 'G0',
        parameters: { Z: options.safeZ },
        comment: 'Move to safe height',
    });

    // Machine cutter compensation (G41/G42) if enabled
    if (options.cutterCompensation === CutterCompensation.MACHINE) {
        if (
            cut.hasOffset &&
            cut.normalSide &&
            cut.normalSide !== NormalSide.NONE
        ) {
            if (cut.normalSide === NormalSide.LEFT) {
                commands.push({
                    code: 'G41',
                    parameters: {},
                    comment: 'Cutter compensation left',
                });
            } else if (cut.normalSide === NormalSide.RIGHT) {
                commands.push({
                    code: 'G42',
                    parameters: {},
                    comment: 'Cutter compensation right',
                });
            }
        } else {
            // No offset or normalSide is NONE - use G40
            commands.push({
                code: 'G40',
                parameters: {},
                comment: 'Cutter compensation off',
            });
        }
    }

    // Lead-in if present
    if (cut.leadIn && cut.leadIn.length > 0) {
        const leadInPoints = cut.leadIn;
        if (leadInPoints.length > 0) {
            // Rapid to lead-in start
            const leadInStart: { x: number; y: number } = leadInPoints[0];
            commands.push({
                code: 'G0',
                parameters: { X: leadInStart.x, Y: leadInStart.y },
                comment: 'Move to lead-in start',
            });

            // Pierce (always in plasma mode)
            if (cut.parameters) {
                commands.push(...generatePierceCommands(cut.parameters));
            }

            // Cut lead-in
            leadInPoints.forEach((point, i) => {
                if (i > 0) {
                    commands.push({
                        code: 'G1',
                        parameters: {
                            X: point.x,
                            Y: point.y,
                        },
                        // Note: Using HAL feed rate, not explicit F parameter
                    });
                }
            });
        }
    } else {
        // Direct move to cut start
        const cutPoints: { x: number; y: number }[] = cut.points || [];
        const start: { x: number; y: number } = cutPoints[0];
        commands.push({
            code: 'G0',
            parameters: { X: start.x, Y: start.y },
            comment: 'Move to cut start',
        });

        if (cut.parameters) {
            commands.push(...generatePierceCommands(cut.parameters));
        }
    }

    // Apply velocity reduction for hole cutting based on cut parameters
    const isHole: boolean = cut.parameters?.isHole || false;
    const underspeedPercent: number | undefined =
        cut.parameters?.holeUnderspeedPercent;

    if (
        isHole &&
        options.adaptiveFeedControl === true &&
        underspeedPercent !== undefined &&
        // eslint-disable-next-line no-magic-numbers
        underspeedPercent < 100
    ) {
        commands.push({
            code: 'M67',
            parameters: { E: 3, Q: underspeedPercent },
            comment: `Reduce velocity to ${underspeedPercent}% for hole cutting`,
        });
    }

    // Cut the cut - use native splines if enabled and available
    if (options.useNativeSplines && cut.originalShape) {
        commands.push(
            ...generateNativeSplineCommands(cut.originalShape, options, cut)
        );
    } else {
        // Fallback to linear interpolation
        const cutPoints: { x: number; y: number }[] = cut.points || [];
        cutPoints.forEach((point, i) => {
            if (i > 0) {
                commands.push({
                    code: 'G1',
                    parameters: {
                        X: point.x,
                        Y: point.y,
                        // Note: Using HAL feed rate, not explicit F parameter
                    },
                });
            }
        });
    }

    // Reset velocity after hole cutting
    if (
        isHole &&
        options.adaptiveFeedControl === true &&
        underspeedPercent !== undefined &&
        // eslint-disable-next-line no-magic-numbers
        underspeedPercent < 100
    ) {
        commands.push({
            code: 'M67',
            parameters: { E: 3, Q: 0 },
            comment: 'Reset velocity to 100%',
        });
    }

    // Lead-out if present
    if (cut.leadOut && cut.leadOut.length > 0) {
        const leadOutPoints = cut.leadOut;
        if (leadOutPoints.length > 0) {
            leadOutPoints.forEach((point, i) => {
                if (i > 0) {
                    commands.push({
                        code: 'G1',
                        parameters: { X: point.x, Y: point.y },
                    });
                }
            });
        }
    }

    // Turn off plasma using QtPlasmaC syntax (always in plasma mode)
    commands.push({
        code: 'M5',
        parameters: { $0: '' },
        comment: 'Plasma torch off',
    });

    // Retract to safe height
    commands.push({
        code: 'G0',
        parameters: { Z: options.safeZ },
        comment: 'Retract to safe height',
    });

    return commands;
}

function generatePierceCommands(parameters: CuttingParameters): GCodeCommand[] {
    const commands: GCodeCommand[] = [];

    // Move to pierce height
    commands.push({
        code: 'G0',
        parameters: { Z: parameters.pierceHeight },
        comment: 'Move to pierce height',
    });

    // Turn on plasma using QtPlasmaC syntax
    commands.push({
        code: 'M3',
        parameters: { $0: '', S: 1 },
        comment: 'Plasma torch on',
    });

    // Pierce delay (QtPlasmaC handles this automatically based on material)
    // But we can still add explicit delay if needed
    if (parameters.pierceDelay && parameters.pierceDelay > 0) {
        commands.push({
            code: 'G4',
            parameters: { P: parameters.pierceDelay },
            comment: 'Pierce delay',
        });
    }

    // Move to cut height
    // TODO should me manually move to cut height?
    commands.push({
        code: 'G1',
        parameters: { Z: parameters.cutHeight },
        comment: 'Move to cut height',
    });

    return commands;
}

function generateFooter(options: GCodeOptions): GCodeCommand[] {
    const commands: GCodeCommand[] = [];

    // Reset velocity reduction to 100% (recommended for postamble)
    if (options.adaptiveFeedControl !== false) {
        commands.push({
            code: 'M68',
            parameters: { E: 3, Q: 0 },
            comment: 'Reset velocity to 100%',
        });
    }

    // Return to material default if material was selected
    if (options.materialNumber !== undefined && options.materialNumber >= 0) {
        commands.push({
            code: 'M190',
            parameters: { P: -1 },
            comment: 'Return to default material',
        });
    }

    // Return to home
    commands.push({
        code: 'G0',
        parameters: { X: 0, Y: 0 },
        comment: 'Return to home',
    });

    // Program end
    commands.push({
        code: 'M2',
        parameters: {},
        comment: 'Program end',
    });

    return commands;
}

function generateNativeSplineCommands(
    shape: ShapeData,
    options: GCodeOptions,
    toolCut?: CutPath
): GCodeCommand[] {
    const commands: GCodeCommand[] = [];

    switch (shape.type) {
        case GeometryType.SPLINE:
            const spline: Spline = shape.geometry as Spline;

            // Use G5.2/G5.3 NURBS commands for splines
            if (spline.controlPoints && spline.controlPoints.length >= 2) {
                if (options.includeComments) {
                    commands.push({
                        code: '',
                        parameters: {},
                        comment: 'Native NURBS spline (G5.2/G5.3)',
                    });
                }

                // G5.2 - Open NURBS data block
                const order: number = spline.degree || DEFAULT_SPLINE_DEGREE;
                commands.push({
                    code: 'G5.2',
                    parameters: {
                        P:
                            spline.weights && spline.weights[0]
                                ? spline.weights[0]
                                : 1,
                        L: order,
                    },
                    comment: 'Start NURBS block',
                });

                // Add control points with weights
                spline.controlPoints.forEach((point: Point2D, i: number) => {
                    if (i > 0) {
                        // Skip first point (already at start position)
                        const weight: number =
                            spline.weights && spline.weights[i]
                                ? spline.weights[i]
                                : 1;
                        commands.push({
                            code: '',
                            parameters: {
                                X: point.x,
                                Y: point.y,
                                P: weight,
                            },
                        });
                    }
                });

                // G5.3 - Close NURBS data block
                commands.push({
                    code: 'G5.3',
                    parameters: {},
                    comment: 'End NURBS block',
                });
            } else {
                // Fallback: convert to linear segments if spline data is incomplete
                if (options.includeComments) {
                    commands.push({
                        code: '',
                        parameters: {},
                        comment:
                            'Spline fallback to linear segments (incomplete NURBS data)',
                    });
                }
                // This would use the existing points array from the ToolPath
                return [];
            }
            break;

        case GeometryType.ARC:
            // Use native arc commands (G2/G3) for arcs
            const arc: Arc = shape.geometry as Arc;
            if (options.includeComments) {
                commands.push({
                    code: '',
                    parameters: {},
                    comment: 'Native arc command',
                });
            }

            // Calculate arc endpoint
            const endX: number =
                arc.center.x + arc.radius * Math.cos(arc.endAngle);
            const endY: number =
                arc.center.y + arc.radius * Math.sin(arc.endAngle);

            // Calculate center offsets from start point
            const startX: number =
                arc.center.x + arc.radius * Math.cos(arc.startAngle);
            const startY: number =
                arc.center.y + arc.radius * Math.sin(arc.startAngle);
            const I: number = arc.center.x - startX;
            const J: number = arc.center.y - startY;

            // Use the arc's actual clockwise property from the geometry
            const isClockwise: boolean = arc.clockwise;

            commands.push({
                code: isClockwise ? 'G2' : 'G3',
                parameters: {
                    X: endX,
                    Y: endY,
                    I: I,
                    J: J,
                },
                comment: `${isClockwise ? 'Clockwise' : 'Counterclockwise'} arc`,
            });
            break;

        case GeometryType.CIRCLE:
            // Convert full circles to arc commands
            const circle: Circle = shape.geometry as Circle;
            if (options.includeComments) {
                commands.push({
                    code: '',
                    parameters: {},
                    comment: 'Native circle (full arc)',
                });
            }

            // Determine circle direction from the operation's execution direction
            // Use the executionClockwise from the toolCut if available
            let circleCode = 'G3'; // Default to counterclockwise
            let directionComment = 'counterclockwise (default)';

            if (toolCut?.executionClockwise === true) {
                circleCode = 'G2';
                directionComment = 'clockwise';
            } else if (toolCut?.executionClockwise === false) {
                circleCode = 'G3';
                directionComment = 'counterclockwise';
            }

            commands.push({
                code: circleCode,
                parameters: {
                    X: circle.center.x + circle.radius,
                    Y: circle.center.y,
                    I: -circle.radius,
                    J: 0,
                },
                comment: `Full circle (${directionComment})`,
            });
            break;

        default:
            // For other shapes (line, polyline, ellipse), return empty array to use linear fallback
            return [];
    }

    return commands;
}

/**
 * Sanitize comment text by removing parentheses to prevent nested comments
 */
function sanitizeComment(comment: string): string {
    return comment.replace(/[()]/g, '');
}

function commandsToString(
    commands: GCodeCommand[],
    options: GCodeOptions
): string {
    return commands
        .map((cmd) => {
            if (!cmd.code && cmd.comment) {
                return options.includeComments
                    ? `(${sanitizeComment(cmd.comment)})`
                    : '';
            }

            let line: string = cmd.code;

            // Handle special F command with raw value
            if (cmd.code === 'F' && cmd.rawValue !== undefined) {
                line += cmd.rawValue;
            } else {
                // Add parameters
                Object.entries(cmd.parameters).forEach(([key, value]) => {
                    if (key.startsWith('$')) {
                        // QtPlasmaC tool syntax (e.g., $0, $1, $2)
                        line += ` ${key}`;
                    } else {
                        // Format numeric values with appropriate precision
                        let formattedValue: string | number = value;
                        if (typeof value === 'number') {
                            // Use 4 decimal places for coordinates, 3 for other values
                            const isCoordinate: boolean = [
                                'X',
                                'Y',
                                'Z',
                                'I',
                                'J',
                                'K',
                            ].includes(key);
                            const precision: number = isCoordinate
                                ? GCODE_COORDINATE_PRECISION
                                : GCODE_PARAMETER_PRECISION;
                            formattedValue = Number(value.toFixed(precision));
                        }
                        // Standard parameter syntax
                        line += ` ${key}${formattedValue}`;
                    }
                });
            }

            // Add comment
            if (options.includeComments && cmd.comment) {
                line += ` (${sanitizeComment(cmd.comment)})`;
            }

            return line;
        })
        .filter((line) => line)
        .join('\n');
}
