import type { Arc } from '$lib/geometry/arc/interfaces';
import { GeometryType } from '$lib/geometry/enums';
import { describe, expect, it } from 'vitest';
import type { DrawingData } from '$lib/cam/drawing/interfaces';
import { Drawing } from '$lib/cam/drawing/classes.svelte';
import type { ShapeData } from '$lib/cam/shape/interfaces';
import { Shape } from '$lib/cam/shape/classes';
import type { CutPath } from '$lib/cam/gcode/interfaces';
import type { Spline } from '$lib/geometry/spline/interfaces';
import { CutterCompensation } from '$lib/cam/gcode/enums';
import { Unit } from '$lib/config/units/units';
import { generateGCode } from './gcode-generator';
import type { Circle } from '$lib/geometry/circle/interfaces';
import { OperationAction } from '$lib/cam/operation/enums';

describe('generateGCode', () => {
    const mockDrawing: DrawingData = {
        shapes: [],
        units: Unit.MM,
        fileName: '',
    };

    const mockCut: CutPath = {
        id: 'path1',
        shapeId: 'shape1',
        points: [
            { x: 0, y: 0 },
            { x: 100, y: 0 },
            { x: 100, y: 100 },
            { x: 0, y: 100 },
            { x: 0, y: 0 },
        ],
        leadIn: [
            { x: -5, y: 0 },
            { x: 0, y: 0 },
        ],
        leadOut: [
            { x: 0, y: 0 },
            { x: -5, y: 0 },
        ],
        isRapid: false,
        parameters: {
            feedRate: 1000,
            pierceHeight: 3.8,
            pierceDelay: 0.5,
            cutHeight: 1.5,
            kerf: 1.5,
            // Lead lengths now come from cut configs, not CuttingParameters
        },
    };

    it('should generate valid G-code header', () => {
        const gcode = generateGCode([mockCut], new Drawing(mockDrawing), {
            units: Unit.MM,
            safeZ: 10,
            rapidFeedRate: 5000,
            includeComments: true,
            cutterCompensation: CutterCompensation.NONE,
        });

        expect(gcode).toContain('G21'); // Metric units
        expect(gcode).toContain('G90'); // Absolute positioning
        expect(gcode).toContain('G64'); // Path blending for plasma
    });

    it('should generate plasma-specific commands', () => {
        const gcode = generateGCode([mockCut], new Drawing(mockDrawing), {
            units: Unit.MM,
            safeZ: 10,
            rapidFeedRate: 5000,
            includeComments: true,
            cutterCompensation: CutterCompensation.NONE,
        });

        expect(gcode).toContain('M3'); // Plasma on
        expect(gcode).toContain('M5'); // Plasma off
        expect(gcode).toContain('G4'); // Pierce delay
    });

    it('should include comments when requested', () => {
        const gcode = generateGCode([mockCut], new Drawing(mockDrawing), {
            units: Unit.MM,
            safeZ: 10,
            rapidFeedRate: 5000,
            includeComments: true,
            cutterCompensation: CutterCompensation.NONE,
        });

        expect(gcode).toContain(
            '(Generated by MetalHead CAM for LinuxCNC QtPlasmaC)'
        );
        expect(gcode).toContain('(Cut 1)');
    });

    it('should not include comments when not requested', () => {
        const gcode = generateGCode([mockCut], new Drawing(mockDrawing), {
            units: Unit.MM,
            safeZ: 10,
            rapidFeedRate: 5000,
            includeComments: false,
            cutterCompensation: CutterCompensation.NONE,
        });

        expect(gcode).not.toContain(
            '(Generated by MetalHead CAM for LinuxCNC QtPlasmaC)'
        );
    });

    it('should handle imperial units', () => {
        const gcode = generateGCode([mockCut], new Drawing(mockDrawing), {
            units: Unit.INCH,
            safeZ: 0.5,
            rapidFeedRate: 200,
            includeComments: true,
            cutterCompensation: CutterCompensation.NONE,
        });

        expect(gcode).toContain('G20'); // Imperial units
    });

    describe('edge cases and advanced features', () => {
        it('should handle empty cuts array', () => {
            const gcode = generateGCode([], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: false,
                cutterCompensation: CutterCompensation.NONE,
            });

            expect(gcode).toContain('G21'); // Should still have header
            expect(gcode).toContain('M2'); // Should still have footer
            expect(gcode).not.toContain('(Cut 1)'); // No cut comments
        });

        it('should handle rapid movements', () => {
            const rapidCut: CutPath = {
                ...mockCut,
                id: 'rapid1',
                isRapid: true,
                parameters: undefined,
                leadIn: undefined,
                leadOut: undefined,
            };

            const gcode = generateGCode([rapidCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
            });

            // Rapids should only generate G0 moves, no cutting (G1) or torch commands
            expect(gcode).toContain('G0'); // Should contain rapid moves
            expect(gcode).not.toContain('G1'); // Should NOT contain cutting moves
            expect(gcode).not.toContain('M3'); // Should NOT contain torch on
            expect(gcode).not.toContain('M5'); // Should NOT contain torch off
            expect(gcode).not.toContain('G4 P'); // Should NOT contain pierce delay
        });

        it('should handle cuts without lead-in/lead-out', () => {
            const simpleCut: CutPath = {
                ...mockCut,
                leadIn: undefined,
                leadOut: undefined,
            };

            const gcode = generateGCode([simpleCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
            });

            expect(gcode).toContain('M3'); // Should still pierce
            expect(gcode).toContain('M5'); // Should still turn off
        });

        it('should handle material selection and THC features', () => {
            const gcode = generateGCode([mockCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
                materialNumber: 5,
                enableTHC: true,
                adaptiveFeedControl: true,
            });

            // With o=0 format, M190 and M66 are not used
            expect(gcode).toContain('(o=0'); // Material parameters in magic comment
            expect(gcode).toContain('M68 E3 Q0'); // Velocity control
            expect(gcode).toContain('M190 P-1'); // Return to default material
        });

        it('should disable velocity reduction when requested', () => {
            const gcode = generateGCode([mockCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
                adaptiveFeedControl: false,
            });

            expect(gcode).not.toContain('M68 E3'); // No velocity commands
            expect(gcode).not.toContain('M67 E3'); // No velocity reduction
        });

        it('should handle hole cutting with velocity reduction when enabled', () => {
            const holeCut: CutPath = {
                ...mockCut,
                parameters: {
                    ...mockCut.parameters!,
                    isHole: true,
                    holeUnderspeedPercent: 60,
                },
            };

            const gcode = generateGCode([holeCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
                adaptiveFeedControl: true,
            });

            expect(gcode).toContain('M67 E3 Q60'); // Reduce velocity for hole
            expect(gcode).toContain('M67 E3 Q0'); // Reset velocity after hole
        });

        it('should not apply velocity reduction for holes when disabled', () => {
            const holeCut: CutPath = {
                ...mockCut,
                parameters: {
                    ...mockCut.parameters!,
                    isHole: true,
                    holeUnderspeedPercent: undefined, // undefined means disabled
                },
            };

            const gcode = generateGCode([holeCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
                adaptiveFeedControl: true,
            });

            expect(gcode).not.toContain('M67 E3'); // No velocity commands at all
        });

        it('should not apply velocity reduction when set to 100%', () => {
            const holeCut: CutPath = {
                ...mockCut,
                parameters: {
                    ...mockCut.parameters!,
                    isHole: true,
                    holeUnderspeedPercent: 100, // 100% means no underspeed
                },
            };

            const gcode = generateGCode([holeCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
                adaptiveFeedControl: true,
            });

            expect(gcode).not.toContain('M67 E3 Q100'); // No velocity commands for 100%
            expect(gcode).not.toContain('M67 E3 Q0'); // No reset needed
        });

        it('should use custom velocity percentage for holes', () => {
            const holeCut: CutPath = {
                ...mockCut,
                parameters: {
                    ...mockCut.parameters!,
                    isHole: true,
                    holeUnderspeedPercent: 40,
                },
            };

            const gcode = generateGCode([holeCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
                adaptiveFeedControl: true,
            });

            expect(gcode).toContain('M67 E3 Q40'); // Use custom 40% velocity
            expect(gcode).toContain('M67 E3 Q0'); // Reset velocity after hole
        });

        it('should handle missing pierce parameters gracefully', () => {
            const cutWithoutParams: CutPath = {
                ...mockCut,
                parameters: undefined,
            };

            const gcode = generateGCode(
                [cutWithoutParams],
                new Drawing(mockDrawing),
                {
                    units: Unit.MM,
                    safeZ: 10,
                    rapidFeedRate: 5000,
                    includeComments: true,
                    cutterCompensation: CutterCompensation.NONE,
                }
            );

            // Should not crash and should include basic commands
            expect(gcode).toContain('G0'); // Rapid moves
            expect(gcode).toContain('G1'); // Linear moves
        });

        it('should handle native spline commands when enabled', () => {
            const splineShape: ShapeData = {
                id: 'spline1',
                type: GeometryType.SPLINE,
                layer: 'test',
                geometry: {
                    controlPoints: [
                        { x: 0, y: 0 },
                        { x: 10, y: 5 },
                        { x: 20, y: 0 },
                    ],
                    weights: [1, 1, 1],
                    knots: [0, 0, 0, 1, 1, 1],
                    degree: 2,
                } as Spline,
            };

            const splineCut: CutPath = {
                ...mockCut,
                originalShape: new Shape(splineShape),
            };

            const gcode = generateGCode([splineCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
                useNativeSplines: true,
            });

            expect(gcode).toContain('G5.2'); // NURBS start
            expect(gcode).toContain('G5.3'); // NURBS end
            expect(gcode).toContain('Native NURBS spline');
        });

        it('should handle native arc commands when enabled', () => {
            const arcShape: ShapeData = {
                id: 'arc1',
                type: GeometryType.ARC,
                layer: 'test',
                geometry: {
                    center: { x: 10, y: 10 },
                    radius: 5,
                    startAngle: 0,
                    endAngle: Math.PI / 2,
                    clockwise: false,
                } as Arc,
            };

            const arcCut: CutPath = {
                ...mockCut,
                originalShape: new Shape(arcShape),
            };

            const gcode = generateGCode([arcCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
                useNativeSplines: true,
            });

            expect(gcode).toContain('G3'); // Counterclockwise arc
            expect(gcode).toContain('Native arc command');
        });

        it('should handle native circle commands when enabled', () => {
            const circleShape: ShapeData = {
                id: 'circle1',
                type: GeometryType.CIRCLE,
                layer: 'test',
                geometry: {
                    center: { x: 10, y: 10 },
                    radius: 5,
                } as Circle,
            };

            const circleCut: CutPath = {
                ...mockCut,
                originalShape: new Shape(circleShape),
                executionClockwise: false, // Counterclockwise execution
            };

            const gcode = generateGCode([circleCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
                useNativeSplines: true,
            });

            expect(gcode).toContain('G3'); // Counterclockwise full circle
            expect(gcode).toContain('Native circle');
            expect(gcode).toContain('counterclockwise');
        });

        it('should handle native circle hole commands with correct direction', () => {
            const circleShape: ShapeData = {
                id: 'circle1',
                type: GeometryType.CIRCLE,
                layer: 'test',
                geometry: {
                    center: { x: 10, y: 10 },
                    radius: 5,
                } as Circle,
            };
            const holeCut: CutPath = {
                ...mockCut,
                originalShape: new Shape(circleShape),
                parameters: {
                    ...mockCut.parameters!,
                    isHole: true,
                },
                executionClockwise: true, // Clockwise execution for holes
            };
            const gcode = generateGCode([holeCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
                useNativeSplines: true,
            });

            expect(gcode).toContain('G2'); // Clockwise for holes
            expect(gcode).toContain('clockwise');
        });

        it('should handle incomplete spline data with fallback', () => {
            const incompleteSpline: ShapeData = {
                id: 'incomplete-spline',
                type: GeometryType.SPLINE,
                layer: 'test',
                geometry: {
                    controlPoints: [{ x: 0, y: 0 }], // Insufficient points
                    weights: [],
                    knots: [],
                    degree: 2,
                    fitPoints: [],
                    closed: false,
                } as Spline,
            };

            const splineCut: CutPath = {
                ...mockCut,
                originalShape: new Shape(incompleteSpline),
            };

            const gcode = generateGCode([splineCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
                useNativeSplines: true,
            });

            // With insufficient control points, the spline generation should return empty array
            // and fall back to using the points array from the ToolPath
            expect(gcode).not.toContain('G5.2'); // Should not use NURBS
            expect(gcode).toContain('G1'); // Should use linear moves instead
        });

        it('should format coordinates with proper precision', () => {
            const precisionCut: CutPath = {
                ...mockCut,
                leadIn: undefined,
                leadOut: undefined,
                points: [
                    { x: 1.123456789, y: 2.987654321 },
                    { x: 10.000001, y: 20.999999 },
                ],
            };

            const gcode = generateGCode(
                [precisionCut],
                new Drawing(mockDrawing),
                {
                    units: Unit.MM,
                    safeZ: 10.123456,
                    rapidFeedRate: 5000,
                    includeComments: false,
                    cutterCompensation: CutterCompensation.NONE,
                }
            );

            // Check that coordinates appear with proper precision somewhere in the output
            // The exact formatting depends on how the cut is processed

            // Check Z coordinate precision (should be 3 decimal places for non-coordinates)
            expect(gcode).toContain('Z10.123');

            // Verify that coordinates exist in the output (may be processed differently)
            expect(gcode).toContain('X1.1235');
            expect(gcode).toContain('Y2.9877');
        });

        it('should handle QtPlasmaC-specific tool syntax', () => {
            const gcode = generateGCode([mockCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
            });

            expect(gcode).toContain('M3 $0'); // QtPlasmaC plasma on syntax
            expect(gcode).toContain('M5 $0'); // QtPlasmaC plasma off syntax
        });

        it('should generate proper HAL feed rate command', () => {
            const gcode = generateGCode([mockCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
            });

            expect(gcode).toContain('F#<_hal[plasmac.cut-feed-rate]>'); // HAL feed rate
        });

        it('should not include plasma commands in non-plasma mode', () => {
            const gcode = generateGCode([mockCut], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: null,
            });

            expect(gcode).toContain('M3'); // Plasma on (always included)
            expect(gcode).toContain('M5'); // Plasma off (always included)
            expect(gcode).toContain('G4'); // Pierce delay (always included)
            // M190 is not used with o=0 format, material params are in magic comment
            expect(gcode).toContain('(o=0'); // Material parameters in magic comment
        });
    });

    describe('Spot Operations', () => {
        const mockSpotCut: CutPath = {
            id: 'spot1',
            shapeId: 'shape1',
            points: [{ x: 50, y: 50 }], // Single point at centroid
            isRapid: false,
            parameters: {
                feedRate: 1000,
                pierceHeight: 3.8,
                pierceDelay: 0.5,
                cutHeight: 1.5,
                kerf: 0,
                action: 'spot' as any, // OperationAction.SPOT
                spotDuration: 100,
            },
        };

        it('should generate spot-specific M-codes', () => {
            const gcode = generateGCode(
                [mockSpotCut],
                new Drawing(mockDrawing),
                {
                    units: Unit.MM,
                    safeZ: 10,
                    rapidFeedRate: 5000,
                    includeComments: true,
                    cutterCompensation: CutterCompensation.NONE,
                }
            );

            expect(gcode).toContain('M3 $2'); // Spotting tool on
            expect(gcode).toContain('M5 $2'); // Spotting tool off
        });

        it('should generate minimal movement sequence for spot', () => {
            const gcode = generateGCode(
                [mockSpotCut],
                new Drawing(mockDrawing),
                {
                    units: Unit.MM,
                    safeZ: 10,
                    rapidFeedRate: 5000,
                    includeComments: true,
                    cutterCompensation: CutterCompensation.NONE,
                }
            );

            expect(gcode).toContain('G91'); // Relative mode
            expect(gcode).toContain('G1 X0.000001'); // Minimal movement
            expect(gcode).toContain('G90'); // Back to absolute mode
        });

        it('should set high feed rate before moving to spot location', () => {
            const gcode = generateGCode(
                [mockSpotCut],
                new Drawing(mockDrawing),
                {
                    units: Unit.MM,
                    safeZ: 10,
                    rapidFeedRate: 5000,
                    includeComments: true,
                    cutterCompensation: CutterCompensation.NONE,
                }
            );

            expect(gcode).toContain('F99999'); // High feed rate

            // Verify F99999 comes before the G0 move to spot location
            const f99999Index = gcode.indexOf('F99999');
            const g0SpotIndex = gcode.indexOf('G0 X50 Y50');
            expect(f99999Index).toBeLessThan(g0SpotIndex);
        });

        it('should move to spot location', () => {
            const gcode = generateGCode(
                [mockSpotCut],
                new Drawing(mockDrawing),
                {
                    units: Unit.MM,
                    safeZ: 10,
                    rapidFeedRate: 5000,
                    includeComments: true,
                    cutterCompensation: CutterCompensation.NONE,
                }
            );

            expect(gcode).toContain('X50'); // Spot X coordinate
            expect(gcode).toContain('Y50'); // Spot Y coordinate
        });

        it('should include spot comment when comments enabled', () => {
            const gcode = generateGCode(
                [mockSpotCut],
                new Drawing(mockDrawing),
                {
                    units: Unit.MM,
                    safeZ: 10,
                    rapidFeedRate: 5000,
                    includeComments: true,
                    cutterCompensation: CutterCompensation.NONE,
                }
            );

            expect(gcode).toContain('(Spot 1)');
        });

        it('should not include pierce commands for spot operations', () => {
            const gcode = generateGCode(
                [mockSpotCut],
                new Drawing(mockDrawing),
                {
                    units: Unit.MM,
                    safeZ: 10,
                    rapidFeedRate: 5000,
                    includeComments: true,
                    cutterCompensation: CutterCompensation.NONE,
                }
            );

            // Spot operations should NOT have pierce delay
            const lines = gcode.split('\n');
            const spotSection = lines.slice(
                lines.findIndex((l) => l.includes('(Spot 1)')),
                lines.findIndex((l) => l.includes('M5 $2'))
            );
            const spotSectionText = spotSection.join('\n');

            expect(spotSectionText).not.toContain('G4'); // No pierce delay
            expect(spotSectionText).not.toContain('M3 $0'); // Not plasma torch
        });
    });

    describe('Spot Action Field Preservation (Integration)', () => {
        it('should use spot G-code when CutPath has action=SPOT', () => {
            const spotCutPath: CutPath = {
                id: 'spot-1',
                shapeId: 'chain-1',
                points: [{ x: 50, y: 50 }],
                isRapid: false,
                parameters: {
                    feedRate: 1000,
                    pierceHeight: 3.8,
                    pierceDelay: 0.5,
                    cutHeight: 1.5,
                    kerf: 0,
                    action: OperationAction.SPOT,
                    spotDuration: 100,
                },
            };

            const gcode = generateGCode(
                [spotCutPath],
                new Drawing(mockDrawing),
                {
                    units: Unit.MM,
                    safeZ: 10,
                    rapidFeedRate: 5000,
                    includeComments: true,
                    cutterCompensation: CutterCompensation.NONE,
                }
            );

            // Should generate spot G-code
            expect(gcode).toContain('M3 $2');
            expect(gcode).toContain('M5 $2');
            expect(gcode).toContain('G91'); // Relative mode
            expect(gcode).toContain('G1 X0.000001'); // Minimal movement
            expect(gcode).toContain('G90'); // Absolute mode

            // Should NOT generate cut G-code
            expect(gcode).not.toContain('M3 $0');
            expect(gcode).not.toContain('M5 $0');
            expect(gcode).not.toContain('G4 P'); // No pierce delay
        });

        it('should use cut G-code when CutPath has action=CUT', () => {
            const cutCutPath: CutPath = {
                id: 'cut-1',
                shapeId: 'chain-1',
                points: [
                    { x: 0, y: 0 },
                    { x: 100, y: 0 },
                ],
                isRapid: false,
                parameters: {
                    feedRate: 1000,
                    pierceHeight: 3.8,
                    pierceDelay: 0.5,
                    cutHeight: 1.5,
                    kerf: 1.5,
                    action: OperationAction.CUT,
                },
            };

            const gcode = generateGCode(
                [cutCutPath],
                new Drawing(mockDrawing),
                {
                    units: Unit.MM,
                    safeZ: 10,
                    rapidFeedRate: 5000,
                    includeComments: true,
                    cutterCompensation: CutterCompensation.NONE,
                }
            );

            // Should generate cut G-code
            expect(gcode).toContain('M3 $0');
            expect(gcode).toContain('M5 $0');
            expect(gcode).toContain('G4 P0.5'); // Pierce delay

            // Should NOT generate spot G-code
            expect(gcode).not.toContain('M3 $2');
            expect(gcode).not.toContain('M5 $2');
        });

        it('should default to cut G-code when action is undefined', () => {
            const undefinedActionPath: CutPath = {
                id: 'cut-1',
                shapeId: 'chain-1',
                points: [
                    { x: 0, y: 0 },
                    { x: 100, y: 0 },
                ],
                isRapid: false,
                parameters: {
                    feedRate: 1000,
                    pierceHeight: 3.8,
                    pierceDelay: 0.5,
                    cutHeight: 1.5,
                    kerf: 1.5,
                    // action: undefined - not set
                },
            };

            const gcode = generateGCode(
                [undefinedActionPath],
                new Drawing(mockDrawing),
                {
                    units: Unit.MM,
                    safeZ: 10,
                    rapidFeedRate: 5000,
                    includeComments: true,
                    cutterCompensation: CutterCompensation.NONE,
                }
            );

            // Should default to cut G-code
            expect(gcode).toContain('M3 $0');
            expect(gcode).toContain('M5 $0');

            // Should NOT generate spot G-code
            expect(gcode).not.toContain('M3 $2');
            expect(gcode).not.toContain('M5 $2');
        });

        it('should handle mixed SPOT and CUT operations in same G-code', () => {
            const paths: CutPath[] = [
                {
                    id: 'cut-1',
                    shapeId: 'chain-1',
                    points: [
                        { x: 0, y: 0 },
                        { x: 100, y: 0 },
                    ],
                    isRapid: false,
                    parameters: {
                        feedRate: 1000,
                        pierceHeight: 3.8,
                        pierceDelay: 0.5,
                        cutHeight: 1.5,
                        kerf: 1.5,
                        action: OperationAction.CUT,
                    },
                },
                {
                    id: 'spot-1',
                    shapeId: 'chain-2',
                    points: [{ x: 50, y: 50 }],
                    isRapid: false,
                    parameters: {
                        feedRate: 1000,
                        pierceHeight: 3.8,
                        pierceDelay: 0.5,
                        cutHeight: 1.5,
                        kerf: 0,
                        action: OperationAction.SPOT,
                        spotDuration: 100,
                    },
                },
            ];

            const gcode = generateGCode(paths, new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: true,
                cutterCompensation: CutterCompensation.NONE,
            });

            // Should have both cut and spot commands
            expect(gcode).toContain('M3 $0'); // Cut command
            expect(gcode).toContain('M5 $0'); // Cut off
            expect(gcode).toContain('M3 $2'); // Spot command
            expect(gcode).toContain('M5 $2'); // Spot off
        });
    });

    describe('Point deduplication', () => {
        it('should remove consecutive duplicate points from cut path', () => {
            const cutWithDuplicates: CutPath = {
                id: 'path1',
                shapeId: 'shape1',
                // Points with near-duplicates that should be filtered out
                points: [
                    { x: 0, y: 0 },
                    { x: 10, y: 10 },
                    { x: 10.00001, y: 10.00001 }, // Too close to previous point
                    { x: 10.00002, y: 10.00002 }, // Too close to previous point
                    { x: 20, y: 20 }, // Far enough to keep
                    { x: 20, y: 20 }, // Exact duplicate
                    { x: 30, y: 30 }, // Far enough to keep
                ],
                leadIn: [
                    { x: -5, y: 0 },
                    { x: -4.99999, y: 0 }, // Too close to previous point
                    { x: 0, y: 0 }, // Far enough to keep
                ],
                leadOut: [
                    { x: 30, y: 30 },
                    { x: 30.00001, y: 30 }, // Too close to previous point
                    { x: 35, y: 30 }, // Far enough to keep
                ],
                isRapid: false,
                parameters: {
                    feedRate: 1000,
                    pierceHeight: 3.8,
                    pierceDelay: 0.5,
                    cutHeight: 1.5,
                    kerf: 1.5,
                },
            };

            const gcode = generateGCode([cutWithDuplicates], new Drawing(mockDrawing), {
                units: Unit.MM,
                safeZ: 10,
                rapidFeedRate: 5000,
                includeComments: false,
                cutterCompensation: CutterCompensation.NONE,
            });

            // Count G1 commands in the output
            const g1Commands = (gcode.match(/G1 X/g) || []).length;

            // Should have fewer G1 commands than original points
            // Original: 3 lead-in points + 7 cut points + 3 lead-out points = 13 total
            // After deduplication: 2 lead-in + 4 cut + 2 lead-out = 8 total
            // But G1 only for points after first, so: 1 lead-in + 3 cut + 1 lead-out = 5 G1 commands
            expect(g1Commands).toBeLessThan(13);
            expect(g1Commands).toBeGreaterThan(0);

            // Verify no consecutive near-duplicate coordinates in output
            const lines = gcode.split('\n');
            const coordinateLines = lines.filter(line => line.includes('G1 X'));

            for (let i = 1; i < coordinateLines.length; i++) {
                const prevMatch = coordinateLines[i - 1].match(/X([\d.-]+) Y([\d.-]+)/);
                const currMatch = coordinateLines[i].match(/X([\d.-]+) Y([\d.-]+)/);

                if (prevMatch && currMatch) {
                    const prevX = parseFloat(prevMatch[1]);
                    const prevY = parseFloat(prevMatch[2]);
                    const currX = parseFloat(currMatch[1]);
                    const currY = parseFloat(currMatch[2]);

                    const distance = Math.sqrt(
                        Math.pow(currX - prevX, 2) + Math.pow(currY - prevY, 2)
                    );

                    // Distance should be at least MIN_POINT_DISTANCE (0.0001)
                    expect(distance).toBeGreaterThanOrEqual(0.0001);
                }
            }
        });
    });
});
